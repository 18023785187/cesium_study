import AxisAlignedBoundingBox from"./AxisAlignedBoundingBox.js";import BoundingSphere from"./BoundingSphere.js";import Cartesian2 from"./Cartesian2.js";import Cartesian3 from"./Cartesian3.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import Ellipsoid from"./Ellipsoid.js";import EllipsoidalOccluder from"./EllipsoidalOccluder.js";import CesiumMath from"./Math.js";import Matrix4 from"./Matrix4.js";import OrientedBoundingBox from"./OrientedBoundingBox.js";import Rectangle from"./Rectangle.js";import TerrainEncoding from"./TerrainEncoding.js";import Transforms from"./Transforms.js";import WebMercatorProjection from"./WebMercatorProjection.js";var HeightmapTessellator={};HeightmapTessellator.DEFAULT_STRUCTURE=Object.freeze({heightScale:1,heightOffset:0,elementsPerHeight:1,stride:1,elementMultiplier:256,isBigEndian:!1});var cartesian3Scratch=new Cartesian3,matrix4Scratch=new Matrix4,minimumScratch=new Cartesian3,maximumScratch=new Cartesian3;HeightmapTessellator.computeVertices=function(e){if(!defined(e)||!defined(e.heightmap))throw new DeveloperError("options.heightmap is required.");if(!defined(e.width)||!defined(e.height))throw new DeveloperError("options.width and options.height are required.");if(!defined(e.nativeRectangle))throw new DeveloperError("options.nativeRectangle is required.");if(!defined(e.skirtHeight))throw new DeveloperError("options.skirtHeight is required.");var r,t,i,a,o=Math.cos,n=Math.sin,l=Math.sqrt,s=Math.atan,m=Math.exp,d=CesiumMath.PI_OVER_TWO,u=CesiumMath.toRadians,h=e.heightmap,c=e.width,g=e.height,f=e.skirtHeight,p=f>0,T=defaultValue(e.isGeographic,!0),E=defaultValue(e.ellipsoid,Ellipsoid.WGS84),v=1/E.maximumRadius,I=Rectangle.clone(e.nativeRectangle),S=Rectangle.clone(e.rectangle);defined(S)?(r=S.west,t=S.south,i=S.east,a=S.north):T?(r=u(I.west),t=u(I.south),i=u(I.east),a=u(I.north)):(r=I.west*v,t=d-2*s(m(-I.south*v)),i=I.east*v,a=d-2*s(m(-I.north*v)));var x=e.relativeToCenter,M=defined(x);x=M?x:Cartesian3.ZERO;var R=defaultValue(e.includeWebMercatorT,!1),w=defaultValue(e.exaggeration,1),C=defaultValue(e.exaggerationRelativeHeight,0),A=1!==w,N=defaultValue(e.structure,HeightmapTessellator.DEFAULT_STRUCTURE),U=defaultValue(N.heightScale,HeightmapTessellator.DEFAULT_STRUCTURE.heightScale),B=defaultValue(N.heightOffset,HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset),V=defaultValue(N.elementsPerHeight,HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight),j=defaultValue(N.stride,HeightmapTessellator.DEFAULT_STRUCTURE.stride),H=defaultValue(N.elementMultiplier,HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier),F=defaultValue(N.isBigEndian,HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian),P=Rectangle.computeWidth(I),O=Rectangle.computeHeight(I),_=P/(c-1),b=O/(g-1);T||(P*=v,O*=v);var y,D,L=E.radiiSquared,W=L.x,Y=L.y,q=L.z,z=65536,G=-65536,k=Transforms.eastNorthUpToFixedFrame(x,E),Z=Matrix4.inverseTransformation(k,matrix4Scratch);R&&(y=WebMercatorProjection.geodeticLatitudeToMercatorAngle(t),D=1/(WebMercatorProjection.geodeticLatitudeToMercatorAngle(a)-y));var J=minimumScratch;J.x=Number.POSITIVE_INFINITY,J.y=Number.POSITIVE_INFINITY,J.z=Number.POSITIVE_INFINITY;var K=maximumScratch;K.x=Number.NEGATIVE_INFINITY,K.y=Number.NEGATIVE_INFINITY,K.z=Number.NEGATIVE_INFINITY;var Q=Number.POSITIVE_INFINITY,X=c*g,$=X+(f>0?2*c+2*g:0),ee=new Array($),re=new Array($),te=new Array($),ie=R?new Array($):[],ae=A?new Array($):[],oe=0,ne=g,le=0,se=c;p&&(--oe,++ne,--le,++se);for(var me=1e-5,de=oe;de<ne;++de){var ue=de;ue<0&&(ue=0),ue>=g&&(ue=g-1);var he=I.north-b*ue,ce=((he=T?u(he):d-2*s(m(-he*v)))-t)/(a-t);ce=CesiumMath.clamp(ce,0,1);var ge=de===oe,fe=de===ne-1;f>0&&(ge?he+=me*O:fe&&(he-=me*O));var pe,Te=o(he),Ee=n(he),ve=q*Ee;R&&(pe=(WebMercatorProjection.geodeticLatitudeToMercatorAngle(he)-y)*D);for(var Ie=le;Ie<se;++Ie){var Se=Ie;Se<0&&(Se=0),Se>=c&&(Se=c-1);var xe,Me,Re=ue*(c*j)+Se*j;if(1===V)xe=h[Re];else if(xe=0,F)for(Me=0;Me<V;++Me)xe=xe*H+h[Re+Me];else for(Me=V-1;Me>=0;--Me)xe=xe*H+h[Re+Me];xe=xe*U+B,G=Math.max(G,xe),z=Math.min(z,xe);var we=I.west+_*Se;T?we=u(we):we*=v;var Ce=(we-r)/(i-r);Ce=CesiumMath.clamp(Ce,0,1);var Ae=ue*c+Se;if(f>0){var Ne=Ie===le,Ue=Ie===se-1,Be=ge||fe||Ne||Ue;if((ge||fe)&&(Ne||Ue))continue;Be&&(xe-=f,Ne?(Ae=X+(g-ue-1),we-=me*P):fe?Ae=X+g+(c-Se-1):Ue?(Ae=X+g+c+ue,we+=me*P):ge&&(Ae=X+g+c+g+Se))}var Ve=Te*o(we),je=Te*n(we),He=W*Ve,Fe=Y*je,Pe=1/l(He*Ve+Fe*je+ve*Ee),Oe=He*Pe,_e=Fe*Pe,be=ve*Pe,ye=new Cartesian3;ye.x=Oe+Ve*xe,ye.y=_e+je*xe,ye.z=be+Ee*xe,Matrix4.multiplyByPoint(Z,ye,cartesian3Scratch),Cartesian3.minimumByComponent(cartesian3Scratch,J,J),Cartesian3.maximumByComponent(cartesian3Scratch,K,K),Q=Math.min(Q,xe),ee[Ae]=ye,te[Ae]=new Cartesian2(Ce,ce),re[Ae]=xe,R&&(ie[Ae]=pe),A&&(ae[Ae]=E.geodeticSurfaceNormal(ye))}}var De,Le,We=BoundingSphere.fromPoints(ee);defined(S)&&(De=OrientedBoundingBox.fromRectangle(S,z,G,E)),M&&(Le=new EllipsoidalOccluder(E).computeHorizonCullingPointPossiblyUnderEllipsoid(x,ee,z));for(var Ye=new AxisAlignedBoundingBox(J,K,x),qe=new TerrainEncoding(x,Ye,Q,G,k,!1,R,A,w,C),ze=new Float32Array($*qe.stride),Ge=0,ke=0;ke<$;++ke)Ge=qe.encode(ze,Ge,ee[ke],te[ke],re[ke],void 0,ie[ke],ae[ke]);return{vertices:ze,maximumHeight:G,minimumHeight:z,encoding:qe,boundingSphere3D:We,orientedBoundingBox:De,occludeePointInScaledSpace:Le}};export default HeightmapTessellator;