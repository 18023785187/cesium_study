import arrayFill from"./arrayFill.js";import BoundingSphere from"./BoundingSphere.js";import Cartesian2 from"./Cartesian2.js";import Cartesian3 from"./Cartesian3.js";import ComponentDatatype from"./ComponentDatatype.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import Ellipsoid from"./Ellipsoid.js";import Geometry from"./Geometry.js";import GeometryAttribute from"./GeometryAttribute.js";import GeometryAttributes from"./GeometryAttributes.js";import GeometryOffsetAttribute from"./GeometryOffsetAttribute.js";import IndexDatatype from"./IndexDatatype.js";import CesiumMath from"./Math.js";import PrimitiveType from"./PrimitiveType.js";import VertexFormat from"./VertexFormat.js";var scratchPosition=new Cartesian3,scratchNormal=new Cartesian3,scratchTangent=new Cartesian3,scratchBitangent=new Cartesian3,scratchNormalST=new Cartesian3,defaultRadii=new Cartesian3(1,1,1),cos=Math.cos,sin=Math.sin;function EllipsoidGeometry(t){t=defaultValue(t,defaultValue.EMPTY_OBJECT);var e=defaultValue(t.radii,defaultRadii),r=defaultValue(t.innerRadii,e),a=defaultValue(t.minimumClock,0),i=defaultValue(t.maximumClock,CesiumMath.TWO_PI),o=defaultValue(t.minimumCone,0),n=defaultValue(t.maximumCone,CesiumMath.PI),s=Math.round(defaultValue(t.stackPartitions,64)),m=Math.round(defaultValue(t.slicePartitions,64)),l=defaultValue(t.vertexFormat,VertexFormat.DEFAULT);if(m<3)throw new DeveloperError("options.slicePartitions cannot be less than three.");if(s<3)throw new DeveloperError("options.stackPartitions cannot be less than three.");this._radii=Cartesian3.clone(e),this._innerRadii=Cartesian3.clone(r),this._minimumClock=a,this._maximumClock=i,this._minimumCone=o,this._maximumCone=n,this._stackPartitions=s,this._slicePartitions=m,this._vertexFormat=VertexFormat.clone(l),this._offsetAttribute=t.offsetAttribute,this._workerName="createEllipsoidGeometry"}EllipsoidGeometry.packedLength=2*Cartesian3.packedLength+VertexFormat.packedLength+7,EllipsoidGeometry.pack=function(t,e,r){if(!defined(t))throw new DeveloperError("value is required");if(!defined(e))throw new DeveloperError("array is required");return r=defaultValue(r,0),Cartesian3.pack(t._radii,e,r),r+=Cartesian3.packedLength,Cartesian3.pack(t._innerRadii,e,r),r+=Cartesian3.packedLength,VertexFormat.pack(t._vertexFormat,e,r),r+=VertexFormat.packedLength,e[r++]=t._minimumClock,e[r++]=t._maximumClock,e[r++]=t._minimumCone,e[r++]=t._maximumCone,e[r++]=t._stackPartitions,e[r++]=t._slicePartitions,e[r]=defaultValue(t._offsetAttribute,-1),e};var unitEllipsoidGeometry,scratchRadii=new Cartesian3,scratchInnerRadii=new Cartesian3,scratchVertexFormat=new VertexFormat,scratchOptions={radii:scratchRadii,innerRadii:scratchInnerRadii,vertexFormat:scratchVertexFormat,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};EllipsoidGeometry.unpack=function(t,e,r){if(!defined(t))throw new DeveloperError("array is required");e=defaultValue(e,0);var a=Cartesian3.unpack(t,e,scratchRadii);e+=Cartesian3.packedLength;var i=Cartesian3.unpack(t,e,scratchInnerRadii);e+=Cartesian3.packedLength;var o=VertexFormat.unpack(t,e,scratchVertexFormat);e+=VertexFormat.packedLength;var n=t[e++],s=t[e++],m=t[e++],l=t[e++],c=t[e++],u=t[e++],p=t[e];return defined(r)?(r._radii=Cartesian3.clone(a,r._radii),r._innerRadii=Cartesian3.clone(i,r._innerRadii),r._vertexFormat=VertexFormat.clone(o,r._vertexFormat),r._minimumClock=n,r._maximumClock=s,r._minimumCone=m,r._maximumCone=l,r._stackPartitions=c,r._slicePartitions=u,r._offsetAttribute=-1===p?void 0:p,r):(scratchOptions.minimumClock=n,scratchOptions.maximumClock=s,scratchOptions.minimumCone=m,scratchOptions.maximumCone=l,scratchOptions.stackPartitions=c,scratchOptions.slicePartitions=u,scratchOptions.offsetAttribute=-1===p?void 0:p,new EllipsoidGeometry(scratchOptions))},EllipsoidGeometry.createGeometry=function(t){var e=t._radii;if(!(e.x<=0||e.y<=0||e.z<=0)){var r=t._innerRadii;if(!(r.x<=0||r.y<=0||r.z<=0)){var a,i,o=t._minimumClock,n=t._maximumClock,s=t._minimumCone,m=t._maximumCone,l=t._vertexFormat,c=t._slicePartitions+1,u=t._stackPartitions+1;(c=Math.round(c*Math.abs(n-o)/CesiumMath.TWO_PI))<2&&(c=2),(u=Math.round(u*Math.abs(m-s)/CesiumMath.PI))<2&&(u=2);var p=0,d=[s],f=[o];for(a=0;a<u;a++)d.push(s+a*(m-s)/(u-1));for(d.push(m),i=0;i<c;i++)f.push(o+i*(n-o)/(c-1));f.push(n);var h=d.length,y=f.length,C=0,v=1,_=r.x!==e.x||r.y!==e.y||r.z!==e.z,x=!1,A=!1,w=!1;_&&(v=2,s>0&&(x=!0,C+=c-1),m<Math.PI&&(A=!0,C+=c-1),(n-o)%CesiumMath.TWO_PI?(w=!0,C+=2*(u-1)+1):C+=1);var b=y*h*v,k=new Float64Array(3*b),F=arrayFill(new Array(b),!1),P=arrayFill(new Array(b),!1),g=c*u*v,E=6*(g+C+1-(c+u)*v),G=IndexDatatype.createTypedArray(g,E),V=l.normal?new Float32Array(3*b):void 0,D=l.tangent?new Float32Array(3*b):void 0,O=l.bitangent?new Float32Array(3*b):void 0,T=l.st?new Float32Array(2*b):void 0,M=new Array(h),I=new Array(h);for(a=0;a<h;a++)M[a]=sin(d[a]),I[a]=cos(d[a]);var j=new Array(y),L=new Array(y);for(i=0;i<y;i++)L[i]=cos(f[i]),j[i]=sin(f[i]);for(a=0;a<h;a++)for(i=0;i<y;i++)k[p++]=e.x*M[a]*L[i],k[p++]=e.y*M[a]*j[i],k[p++]=e.z*I[a];var R,N,z,S,B=b/2;if(_)for(a=0;a<h;a++)for(i=0;i<y;i++)k[p++]=r.x*M[a]*L[i],k[p++]=r.y*M[a]*j[i],k[p++]=r.z*I[a],F[B]=!0,a>0&&a!==h-1&&0!==i&&i!==y-1&&(P[B]=!0),B++;for(p=0,a=1;a<h-2;a++)for(R=a*y,N=(a+1)*y,i=1;i<y-2;i++)G[p++]=N+i,G[p++]=N+i+1,G[p++]=R+i+1,G[p++]=N+i,G[p++]=R+i+1,G[p++]=R+i;if(_){var U=h*y;for(a=1;a<h-2;a++)for(R=U+a*y,N=U+(a+1)*y,i=1;i<y-2;i++)G[p++]=N+i,G[p++]=R+i,G[p++]=R+i+1,G[p++]=N+i,G[p++]=R+i+1,G[p++]=N+i+1}if(_){if(x)for(S=h*y,a=1;a<y-2;a++)G[p++]=a,G[p++]=a+1,G[p++]=S+a+1,G[p++]=a,G[p++]=S+a+1,G[p++]=S+a;if(A)for(z=h*y-y,S=h*y*v-y,a=1;a<y-2;a++)G[p++]=z+a+1,G[p++]=z+a,G[p++]=S+a,G[p++]=z+a+1,G[p++]=S+a,G[p++]=S+a+1}if(w){for(a=1;a<h-2;a++)S=y*h+y*a,z=y*a,G[p++]=S,G[p++]=z+y,G[p++]=z,G[p++]=S,G[p++]=S+y,G[p++]=z+y;for(a=1;a<h-2;a++)S=y*h+y*(a+1)-1,z=y*(a+1)-1,G[p++]=z+y,G[p++]=S,G[p++]=z,G[p++]=z+y,G[p++]=S+y,G[p++]=S}var W=new GeometryAttributes;l.position&&(W.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:k}));var q,Y=0,J=0,X=0,Z=0,H=b/2,K=Ellipsoid.fromCartesian3(e),Q=Ellipsoid.fromCartesian3(r);if(l.st||l.normal||l.tangent||l.bitangent){for(a=0;a<b;a++){q=F[a]?Q:K;var $=Cartesian3.fromArray(k,3*a,scratchPosition),tt=q.geodeticSurfaceNormal($,scratchNormal);if(P[a]&&Cartesian3.negate(tt,tt),l.st){var et=Cartesian2.negate(tt,scratchNormalST);T[Y++]=Math.atan2(et.y,et.x)/CesiumMath.TWO_PI+.5,T[Y++]=Math.asin(tt.z)/Math.PI+.5}if(l.normal&&(V[J++]=tt.x,V[J++]=tt.y,V[J++]=tt.z),l.tangent||l.bitangent){var rt,at=scratchTangent,it=0;if(F[a]&&(it=H),rt=!x&&a>=it&&a<it+2*y?Cartesian3.UNIT_X:Cartesian3.UNIT_Z,Cartesian3.cross(rt,tt,at),Cartesian3.normalize(at,at),l.tangent&&(D[X++]=at.x,D[X++]=at.y,D[X++]=at.z),l.bitangent){var ot=Cartesian3.cross(tt,at,scratchBitangent);Cartesian3.normalize(ot,ot),O[Z++]=ot.x,O[Z++]=ot.y,O[Z++]=ot.z}}}l.st&&(W.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:T})),l.normal&&(W.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:V})),l.tangent&&(W.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:D})),l.bitangent&&(W.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:O}))}if(defined(t._offsetAttribute)){var nt=k.length,st=new Uint8Array(nt/3),mt=t._offsetAttribute===GeometryOffsetAttribute.NONE?0:1;arrayFill(st,mt),W.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:st})}return new Geometry({attributes:W,indices:G,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:BoundingSphere.fromEllipsoid(K),offsetAttribute:t._offsetAttribute})}}},EllipsoidGeometry.getUnitEllipsoid=function(){return defined(unitEllipsoidGeometry)||(unitEllipsoidGeometry=EllipsoidGeometry.createGeometry(new EllipsoidGeometry({radii:new Cartesian3(1,1,1),vertexFormat:VertexFormat.POSITION_ONLY}))),unitEllipsoidGeometry};export default EllipsoidGeometry;