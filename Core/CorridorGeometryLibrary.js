import Cartesian3 from"./Cartesian3.js";import CornerType from"./CornerType.js";import defined from"./defined.js";import CesiumMath from"./Math.js";import Matrix3 from"./Matrix3.js";import PolylinePipeline from"./PolylinePipeline.js";import PolylineVolumeGeometryLibrary from"./PolylineVolumeGeometryLibrary.js";import Quaternion from"./Quaternion.js";var CorridorGeometryLibrary={},scratch1=new Cartesian3,scratch2=new Cartesian3,scratch3=new Cartesian3,scratch4=new Cartesian3,scaleArray2=[new Cartesian3,new Cartesian3],cartesian1=new Cartesian3,cartesian2=new Cartesian3,cartesian3=new Cartesian3,cartesian4=new Cartesian3,cartesian5=new Cartesian3,cartesian6=new Cartesian3,cartesian7=new Cartesian3,cartesian8=new Cartesian3,cartesian9=new Cartesian3,cartesian10=new Cartesian3,quaterion=new Quaternion,rotMatrix=new Matrix3;function computeRoundCorner(a,r,e,t,n){var i,s=Cartesian3.angleBetween(Cartesian3.subtract(r,a,scratch1),Cartesian3.subtract(e,a,scratch2)),o=t===CornerType.BEVELED?1:Math.ceil(s/CesiumMath.toRadians(5))+1,c=3*o,l=new Array(c);l[c-3]=e.x,l[c-2]=e.y,l[c-1]=e.z,i=n?Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(a,scratch1),s/o,quaterion),rotMatrix):Matrix3.fromQuaternion(Quaternion.fromAxisAngle(a,s/o,quaterion),rotMatrix);var C=0;r=Cartesian3.clone(r,scratch1);for(var y=0;y<o;y++)r=Matrix3.multiplyByVector(i,r,r),l[C++]=r.x,l[C++]=r.y,l[C++]=r.z;return l}function addEndCaps(a){var r=cartesian1,e=cartesian2,t=cartesian3,n=a[1];e=Cartesian3.fromArray(a[1],n.length-3,e),t=Cartesian3.fromArray(a[0],0,t);var i=computeRoundCorner(r=Cartesian3.midpoint(e,t,r),e,t,CornerType.ROUNDED,!1),s=a.length-1,o=a[s-1];return n=a[s],e=Cartesian3.fromArray(o,o.length-3,e),t=Cartesian3.fromArray(n,0,t),[i,computeRoundCorner(r=Cartesian3.midpoint(e,t,r),e,t,CornerType.ROUNDED,!1)]}function computeMiteredCorner(a,r,e,t){var n=scratch1;return t||(r=Cartesian3.negate(r,r)),[(n=Cartesian3.add(a,r,n)).x,n.y,n.z,e.x,e.y,e.z]}function addShiftedPositions(a,r,e,t){for(var n=new Array(a.length),i=new Array(a.length),s=Cartesian3.multiplyByScalar(r,e,scratch1),o=Cartesian3.negate(s,scratch2),c=0,l=a.length-1,C=0;C<a.length;C+=3){var y=Cartesian3.fromArray(a,C,scratch3),d=Cartesian3.add(y,o,scratch4);n[c++]=d.x,n[c++]=d.y,n[c++]=d.z;var u=Cartesian3.add(y,s,scratch4);i[l--]=u.z,i[l--]=u.y,i[l--]=u.x}return t.push(n,i),t}CorridorGeometryLibrary.addAttribute=function(a,r,e,t){var n=r.x,i=r.y,s=r.z;defined(e)&&(a[e]=n,a[e+1]=i,a[e+2]=s),defined(t)&&(a[t]=s,a[t-1]=i,a[t-2]=n)};var scratchForwardProjection=new Cartesian3,scratchBackwardProjection=new Cartesian3;CorridorGeometryLibrary.computePositions=function(a){var r=a.granularity,e=a.positions,t=a.ellipsoid,n=a.width/2,i=a.cornerType,s=a.saveAttributes,o=cartesian1,c=cartesian2,l=cartesian3,C=cartesian4,y=cartesian5,d=cartesian6,u=cartesian7,m=cartesian8,p=cartesian9,h=cartesian10,f=[],g=s?[]:void 0,A=s?[]:void 0,w=e[0],P=e[1];c=Cartesian3.normalize(Cartesian3.subtract(P,w,c),c),o=t.geodeticSurfaceNormal(w,o),C=Cartesian3.normalize(Cartesian3.cross(o,c,C),C),s&&(g.push(C.x,C.y,C.z),A.push(o.x,o.y,o.z)),u=Cartesian3.clone(w,u),w=P,l=Cartesian3.negate(c,l);var x,z,v=[],M=e.length;for(x=1;x<M-1;x++){o=t.geodeticSurfaceNormal(w,o),P=e[x+1],c=Cartesian3.normalize(Cartesian3.subtract(P,w,c),c),y=Cartesian3.normalize(Cartesian3.add(c,l,y),y);var S=Cartesian3.multiplyByScalar(o,Cartesian3.dot(c,o),scratchForwardProjection);Cartesian3.subtract(c,S,S),Cartesian3.normalize(S,S);var B=Cartesian3.multiplyByScalar(o,Cartesian3.dot(l,o),scratchBackwardProjection);if(Cartesian3.subtract(l,B,B),Cartesian3.normalize(B,B),!CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(S,B)),1,CesiumMath.EPSILON7)){y=Cartesian3.cross(y,o,y),y=Cartesian3.cross(o,y,y),y=Cartesian3.normalize(y,y);var E=n/Math.max(.25,Cartesian3.magnitude(Cartesian3.cross(y,l,scratch1))),b=PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(c,l,w,t);y=Cartesian3.multiplyByScalar(y,E,y),b?(m=Cartesian3.add(w,y,m),h=Cartesian3.add(m,Cartesian3.multiplyByScalar(C,n,h),h),p=Cartesian3.add(m,Cartesian3.multiplyByScalar(C,2*n,p),p),scaleArray2[0]=Cartesian3.clone(u,scaleArray2[0]),scaleArray2[1]=Cartesian3.clone(h,scaleArray2[1]),f=addShiftedPositions(PolylinePipeline.generateArc({positions:scaleArray2,granularity:r,ellipsoid:t}),C,n,f),s&&(g.push(C.x,C.y,C.z),A.push(o.x,o.y,o.z)),d=Cartesian3.clone(p,d),C=Cartesian3.normalize(Cartesian3.cross(o,c,C),C),p=Cartesian3.add(m,Cartesian3.multiplyByScalar(C,2*n,p),p),u=Cartesian3.add(m,Cartesian3.multiplyByScalar(C,n,u),u),i===CornerType.ROUNDED||i===CornerType.BEVELED?v.push({leftPositions:computeRoundCorner(m,d,p,i,b)}):v.push({leftPositions:computeMiteredCorner(w,Cartesian3.negate(y,y),p,b)})):(p=Cartesian3.add(w,y,p),h=Cartesian3.add(p,Cartesian3.negate(Cartesian3.multiplyByScalar(C,n,h),h),h),m=Cartesian3.add(p,Cartesian3.negate(Cartesian3.multiplyByScalar(C,2*n,m),m),m),scaleArray2[0]=Cartesian3.clone(u,scaleArray2[0]),scaleArray2[1]=Cartesian3.clone(h,scaleArray2[1]),f=addShiftedPositions(PolylinePipeline.generateArc({positions:scaleArray2,granularity:r,ellipsoid:t}),C,n,f),s&&(g.push(C.x,C.y,C.z),A.push(o.x,o.y,o.z)),d=Cartesian3.clone(m,d),C=Cartesian3.normalize(Cartesian3.cross(o,c,C),C),m=Cartesian3.add(p,Cartesian3.negate(Cartesian3.multiplyByScalar(C,2*n,m),m),m),u=Cartesian3.add(p,Cartesian3.negate(Cartesian3.multiplyByScalar(C,n,u),u),u),i===CornerType.ROUNDED||i===CornerType.BEVELED?v.push({rightPositions:computeRoundCorner(p,d,m,i,b)}):v.push({rightPositions:computeMiteredCorner(w,y,m,b)})),l=Cartesian3.negate(c,l)}w=P}return o=t.geodeticSurfaceNormal(w,o),scaleArray2[0]=Cartesian3.clone(u,scaleArray2[0]),scaleArray2[1]=Cartesian3.clone(w,scaleArray2[1]),f=addShiftedPositions(PolylinePipeline.generateArc({positions:scaleArray2,granularity:r,ellipsoid:t}),C,n,f),s&&(g.push(C.x,C.y,C.z),A.push(o.x,o.y,o.z)),i===CornerType.ROUNDED&&(z=addEndCaps(f)),{positions:f,corners:v,lefts:g,normals:A,endPositions:z}};export default CorridorGeometryLibrary;