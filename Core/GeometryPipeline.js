import AttributeCompression from"./AttributeCompression.js";import barycentricCoordinates from"./barycentricCoordinates.js";import BoundingSphere from"./BoundingSphere.js";import Cartesian2 from"./Cartesian2.js";import Cartesian3 from"./Cartesian3.js";import Cartesian4 from"./Cartesian4.js";import Cartographic from"./Cartographic.js";import ComponentDatatype from"./ComponentDatatype.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import EncodedCartesian3 from"./EncodedCartesian3.js";import GeographicProjection from"./GeographicProjection.js";import Geometry from"./Geometry.js";import GeometryAttribute from"./GeometryAttribute.js";import GeometryType from"./GeometryType.js";import IndexDatatype from"./IndexDatatype.js";import Intersect from"./Intersect.js";import IntersectionTests from"./IntersectionTests.js";import CesiumMath from"./Math.js";import Matrix3 from"./Matrix3.js";import Matrix4 from"./Matrix4.js";import Plane from"./Plane.js";import PrimitiveType from"./PrimitiveType.js";import Tipsify from"./Tipsify.js";var GeometryPipeline={};function addTriangle(e,t,r,i,n){e[t++]=r,e[t++]=i,e[t++]=i,e[t++]=n,e[t++]=n,e[t]=r}function trianglesToLines(e){for(var t=e.length,r=t/3*6,i=IndexDatatype.createTypedArray(t,r),n=0,a=0;a<t;a+=3,n+=6)addTriangle(i,n,e[a],e[a+1],e[a+2]);return i}function triangleStripToLines(e){var t=e.length;if(t>=3){var r=6*(t-2),i=IndexDatatype.createTypedArray(t,r);addTriangle(i,0,e[0],e[1],e[2]);for(var n=6,a=3;a<t;++a,n+=6)addTriangle(i,n,e[a-1],e[a],e[a-2]);return i}return new Uint16Array}function triangleFanToLines(e){if(e.length>0){for(var t=e.length-1,r=6*(t-1),i=IndexDatatype.createTypedArray(t,r),n=e[0],a=0,o=1;o<t;++o,a+=6)addTriangle(i,a,n,e[o],e[o+1]);return i}return new Uint16Array}function copyAttributesDescriptions(e){var t={};for(var r in e)if(e.hasOwnProperty(r)&&defined(e[r])&&defined(e[r].values)){var i=e[r];t[r]=new GeometryAttribute({componentDatatype:i.componentDatatype,componentsPerAttribute:i.componentsPerAttribute,normalize:i.normalize,values:[]})}return t}function copyVertex(e,t,r){for(var i in t)if(t.hasOwnProperty(i)&&defined(t[i])&&defined(t[i].values))for(var n=t[i],a=0;a<n.componentsPerAttribute;++a)e[i].values.push(n.values[r*n.componentsPerAttribute+a])}GeometryPipeline.toWireframe=function(e){if(!defined(e))throw new DeveloperError("geometry is required.");var t=e.indices;if(defined(t)){switch(e.primitiveType){case PrimitiveType.TRIANGLES:e.indices=trianglesToLines(t);break;case PrimitiveType.TRIANGLE_STRIP:e.indices=triangleStripToLines(t);break;case PrimitiveType.TRIANGLE_FAN:e.indices=triangleFanToLines(t);break;default:throw new DeveloperError("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=PrimitiveType.LINES}return e},GeometryPipeline.createLineSegmentsForVectors=function(e,t,r){if(t=defaultValue(t,"normal"),!defined(e))throw new DeveloperError("geometry is required.");if(!defined(e.attributes.position))throw new DeveloperError("geometry.attributes.position is required.");if(!defined(e.attributes[t]))throw new DeveloperError("geometry.attributes must have an attribute with the same name as the attributeName parameter, "+t+".");r=defaultValue(r,1e4);for(var i,n=e.attributes.position.values,a=e.attributes[t].values,o=n.length,s=new Float64Array(2*o),u=0,p=0;p<o;p+=3)s[u++]=n[p],s[u++]=n[p+1],s[u++]=n[p+2],s[u++]=n[p]+a[p]*r,s[u++]=n[p+1]+a[p+1]*r,s[u++]=n[p+2]+a[p+2]*r;var c=e.boundingSphere;return defined(c)&&(i=new BoundingSphere(c.center,c.radius+r)),new Geometry({attributes:{position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:s})},primitiveType:PrimitiveType.LINES,boundingSphere:i})},GeometryPipeline.createAttributeLocations=function(e){if(!defined(e))throw new DeveloperError("geometry is required.");var t,r=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],i=e.attributes,n={},a=0,o=r.length;for(t=0;t<o;++t){var s=r[t];defined(i[s])&&(n[s]=a++)}for(var u in i)i.hasOwnProperty(u)&&!defined(n[u])&&(n[u]=a++);return n},GeometryPipeline.reorderForPreVertexCache=function(e){if(!defined(e))throw new DeveloperError("geometry is required.");var t=Geometry.computeNumberOfVertices(e),r=e.indices;if(defined(r)){for(var i=new Int32Array(t),n=0;n<t;n++)i[n]=-1;for(var a,o=r,s=o.length,u=IndexDatatype.createTypedArray(t,s),p=0,c=0,l=0;p<s;)-1!==(a=i[o[p]])?u[c]=a:(i[a=o[p]]=l,u[c]=l,++l),++p,++c;e.indices=u;var d=e.attributes;for(var m in d)if(d.hasOwnProperty(m)&&defined(d[m])&&defined(d[m].values)){for(var f=d[m],y=f.values,v=0,h=f.componentsPerAttribute,b=ComponentDatatype.createTypedArray(f.componentDatatype,l*h);v<t;){var C=i[v];if(-1!==C)for(var g=0;g<h;g++)b[h*C+g]=y[h*v+g];++v}f.values=b}}return e},GeometryPipeline.reorderForPostVertexCache=function(e,t){if(!defined(e))throw new DeveloperError("geometry is required.");var r=e.indices;if(e.primitiveType===PrimitiveType.TRIANGLES&&defined(r)){for(var i=r.length,n=0,a=0;a<i;a++)r[a]>n&&(n=r[a]);e.indices=Tipsify.tipsify({indices:r,maximumIndex:n,cacheSize:t})}return e},GeometryPipeline.fitToUnsignedShortIndices=function(e){if(!defined(e))throw new DeveloperError("geometry is required.");if(defined(e.indices)&&e.primitiveType!==PrimitiveType.TRIANGLES&&e.primitiveType!==PrimitiveType.LINES&&e.primitiveType!==PrimitiveType.POINTS)throw new DeveloperError("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");var t=[],r=Geometry.computeNumberOfVertices(e);if(defined(e.indices)&&r>=CesiumMath.SIXTY_FOUR_KILOBYTES){var i,n=[],a=[],o=0,s=copyAttributesDescriptions(e.attributes),u=e.indices,p=u.length;e.primitiveType===PrimitiveType.TRIANGLES?i=3:e.primitiveType===PrimitiveType.LINES?i=2:e.primitiveType===PrimitiveType.POINTS&&(i=1);for(var c=0;c<p;c+=i){for(var l=0;l<i;++l){var d=u[c+l],m=n[d];defined(m)||(m=o++,n[d]=m,copyVertex(s,e.attributes,d)),a.push(m)}o+i>=CesiumMath.SIXTY_FOUR_KILOBYTES&&(t.push(new Geometry({attributes:s,indices:a,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),n=[],a=[],o=0,s=copyAttributesDescriptions(e.attributes))}0!==a.length&&t.push(new Geometry({attributes:s,indices:a,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};var scratchProjectTo2DCartesian3=new Cartesian3,scratchProjectTo2DCartographic=new Cartographic;GeometryPipeline.projectTo2D=function(e,t,r,i,n){if(!defined(e))throw new DeveloperError("geometry is required.");if(!defined(t))throw new DeveloperError("attributeName is required.");if(!defined(r))throw new DeveloperError("attributeName3D is required.");if(!defined(i))throw new DeveloperError("attributeName2D is required.");if(!defined(e.attributes[t]))throw new DeveloperError("geometry must have attribute matching the attributeName argument: "+t+".");if(e.attributes[t].componentDatatype!==ComponentDatatype.DOUBLE)throw new DeveloperError("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");for(var a=e.attributes[t],o=(n=defined(n)?n:new GeographicProjection).ellipsoid,s=a.values,u=new Float64Array(s.length),p=0,c=0;c<s.length;c+=3){var l=Cartesian3.fromArray(s,c,scratchProjectTo2DCartesian3),d=o.cartesianToCartographic(l,scratchProjectTo2DCartographic);if(!defined(d))throw new DeveloperError("Could not project point ("+l.x+", "+l.y+", "+l.z+") to 2D.");var m=n.project(d,scratchProjectTo2DCartesian3);u[p++]=m.x,u[p++]=m.y,u[p++]=m.z}return e.attributes[r]=a,e.attributes[i]=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:u}),delete e.attributes[t],e};var encodedResult={high:0,low:0};GeometryPipeline.encodeAttribute=function(e,t,r,i){if(!defined(e))throw new DeveloperError("geometry is required.");if(!defined(t))throw new DeveloperError("attributeName is required.");if(!defined(r))throw new DeveloperError("attributeHighName is required.");if(!defined(i))throw new DeveloperError("attributeLowName is required.");if(!defined(e.attributes[t]))throw new DeveloperError("geometry must have attribute matching the attributeName argument: "+t+".");if(e.attributes[t].componentDatatype!==ComponentDatatype.DOUBLE)throw new DeveloperError("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");for(var n=e.attributes[t],a=n.values,o=a.length,s=new Float32Array(o),u=new Float32Array(o),p=0;p<o;++p)EncodedCartesian3.encode(a[p],encodedResult),s[p]=encodedResult.high,u[p]=encodedResult.low;var c=n.componentsPerAttribute;return e.attributes[r]=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:c,values:s}),e.attributes[i]=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:c,values:u}),delete e.attributes[t],e};var scratchCartesian3=new Cartesian3;function transformPoint(e,t){if(defined(t))for(var r=t.values,i=r.length,n=0;n<i;n+=3)Cartesian3.unpack(r,n,scratchCartesian3),Matrix4.multiplyByPoint(e,scratchCartesian3,scratchCartesian3),Cartesian3.pack(scratchCartesian3,r,n)}function transformVector(e,t){if(defined(t))for(var r=t.values,i=r.length,n=0;n<i;n+=3)Cartesian3.unpack(r,n,scratchCartesian3),Matrix3.multiplyByVector(e,scratchCartesian3,scratchCartesian3),scratchCartesian3=Cartesian3.normalize(scratchCartesian3,scratchCartesian3),Cartesian3.pack(scratchCartesian3,r,n)}var inverseTranspose=new Matrix4,normalMatrix=new Matrix3;function findAttributesInAllGeometries(e,t){var r,i=e.length,n={},a=e[0][t].attributes;for(r in a)if(a.hasOwnProperty(r)&&defined(a[r])&&defined(a[r].values)){for(var o=a[r],s=o.values.length,u=!0,p=1;p<i;++p){var c=e[p][t].attributes[r];if(!defined(c)||o.componentDatatype!==c.componentDatatype||o.componentsPerAttribute!==c.componentsPerAttribute||o.normalize!==c.normalize){u=!1;break}s+=c.values.length}u&&(n[r]=new GeometryAttribute({componentDatatype:o.componentDatatype,componentsPerAttribute:o.componentsPerAttribute,normalize:o.normalize,values:ComponentDatatype.createTypedArray(o.componentDatatype,s)}))}return n}GeometryPipeline.transformToWorldCoordinates=function(e){if(!defined(e))throw new DeveloperError("instance is required.");var t=e.modelMatrix;if(Matrix4.equals(t,Matrix4.IDENTITY))return e;var r=e.geometry.attributes;transformPoint(t,r.position),transformPoint(t,r.prevPosition),transformPoint(t,r.nextPosition),(defined(r.normal)||defined(r.tangent)||defined(r.bitangent))&&(Matrix4.inverse(t,inverseTranspose),Matrix4.transpose(inverseTranspose,inverseTranspose),Matrix4.getMatrix3(inverseTranspose,normalMatrix),transformVector(normalMatrix,r.normal),transformVector(normalMatrix,r.tangent),transformVector(normalMatrix,r.bitangent));var i=e.geometry.boundingSphere;return defined(i)&&(e.geometry.boundingSphere=BoundingSphere.transform(i,t,i)),e.modelMatrix=Matrix4.clone(Matrix4.IDENTITY),e};var tempScratch=new Cartesian3;function combineGeometries(e,t){var r,i,n,a,o=e.length,s=e[0].modelMatrix,u=defined(e[0][t].indices),p=e[0][t].primitiveType;for(i=1;i<o;++i){if(!Matrix4.equals(e[i].modelMatrix,s))throw new DeveloperError("All instances must have the same modelMatrix.");if(defined(e[i][t].indices)!==u)throw new DeveloperError("All instance geometries must have an indices or not have one.");if(e[i][t].primitiveType!==p)throw new DeveloperError("All instance geometries must have the same primitiveType.")}var c,l,d,m,f=findAttributesInAllGeometries(e,t);for(r in f)if(f.hasOwnProperty(r))for(c=f[r].values,a=0,i=0;i<o;++i)for(d=(l=e[i][t].attributes[r].values).length,n=0;n<d;++n)c[a++]=l[n];if(u){var y=0;for(i=0;i<o;++i)y+=e[i][t].indices.length;var v=Geometry.computeNumberOfVertices(new Geometry({attributes:f,primitiveType:PrimitiveType.POINTS})),h=IndexDatatype.createTypedArray(v,y),b=0,C=0;for(i=0;i<o;++i){var g=e[i][t].indices,P=g.length;for(a=0;a<P;++a)h[b++]=C+g[a];C+=Geometry.computeNumberOfVertices(e[i][t])}m=h}var T,w=new Cartesian3,A=0;for(i=0;i<o;++i){if(T=e[i][t].boundingSphere,!defined(T)){w=void 0;break}Cartesian3.add(T.center,w,w)}if(defined(w))for(Cartesian3.divideByScalar(w,o,w),i=0;i<o;++i){T=e[i][t].boundingSphere;var S=Cartesian3.magnitude(Cartesian3.subtract(T.center,w,tempScratch))+T.radius;S>A&&(A=S)}return new Geometry({attributes:f,indices:m,primitiveType:p,boundingSphere:defined(w)?new BoundingSphere(w,A):void 0})}GeometryPipeline.combineInstances=function(e){if(!defined(e)||e.length<1)throw new DeveloperError("instances is required and must have length greater than zero.");for(var t=[],r=[],i=e.length,n=0;n<i;++n){var a=e[n];defined(a.geometry)?t.push(a):defined(a.westHemisphereGeometry)&&defined(a.eastHemisphereGeometry)&&r.push(a)}var o=[];return t.length>0&&o.push(combineGeometries(t,"geometry")),r.length>0&&(o.push(combineGeometries(r,"westHemisphereGeometry")),o.push(combineGeometries(r,"eastHemisphereGeometry"))),o};var normal=new Cartesian3,v0=new Cartesian3,v1=new Cartesian3,v2=new Cartesian3;GeometryPipeline.computeNormal=function(e){if(!defined(e))throw new DeveloperError("geometry is required.");if(!defined(e.attributes.position)||!defined(e.attributes.position.values))throw new DeveloperError("geometry.attributes.position.values is required.");if(!defined(e.indices))throw new DeveloperError("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!=0)throw new DeveloperError("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==PrimitiveType.TRIANGLES)throw new DeveloperError("geometry.primitiveType must be PrimitiveType.TRIANGLES.");var t,r=e.indices,i=e.attributes,n=i.position.values,a=i.position.values.length/3,o=r.length,s=new Array(a),u=new Array(o/3),p=new Array(o);for(t=0;t<a;t++)s[t]={indexOffset:0,count:0,currentCount:0};var c=0;for(t=0;t<o;t+=3){var l=r[t],d=r[t+1],m=r[t+2],f=3*l,y=3*d,v=3*m;v0.x=n[f],v0.y=n[f+1],v0.z=n[f+2],v1.x=n[y],v1.y=n[y+1],v1.z=n[y+2],v2.x=n[v],v2.y=n[v+1],v2.z=n[v+2],s[l].count++,s[d].count++,s[m].count++,Cartesian3.subtract(v1,v0,v1),Cartesian3.subtract(v2,v0,v2),u[c]=Cartesian3.cross(v1,v2,new Cartesian3),c++}var h,b=0;for(t=0;t<a;t++)s[t].indexOffset+=b,b+=s[t].count;for(c=0,t=0;t<o;t+=3){var C=(h=s[r[t]]).indexOffset+h.currentCount;p[C]=c,h.currentCount++,p[C=(h=s[r[t+1]]).indexOffset+h.currentCount]=c,h.currentCount++,p[C=(h=s[r[t+2]]).indexOffset+h.currentCount]=c,h.currentCount++,c++}var g=new Float32Array(3*a);for(t=0;t<a;t++){var P=3*t;if(h=s[t],Cartesian3.clone(Cartesian3.ZERO,normal),h.count>0){for(c=0;c<h.count;c++)Cartesian3.add(normal,u[p[h.indexOffset+c]],normal);Cartesian3.equalsEpsilon(Cartesian3.ZERO,normal,CesiumMath.EPSILON10)&&Cartesian3.clone(u[p[h.indexOffset]],normal)}Cartesian3.equalsEpsilon(Cartesian3.ZERO,normal,CesiumMath.EPSILON10)&&(normal.z=1),Cartesian3.normalize(normal,normal),g[P]=normal.x,g[P+1]=normal.y,g[P+2]=normal.z}return e.attributes.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:g}),e};var normalScratch=new Cartesian3,normalScale=new Cartesian3,tScratch=new Cartesian3;GeometryPipeline.computeTangentAndBitangent=function(e){if(!defined(e))throw new DeveloperError("geometry is required.");var t=e.attributes,r=e.indices;if(!defined(t.position)||!defined(t.position.values))throw new DeveloperError("geometry.attributes.position.values is required.");if(!defined(t.normal)||!defined(t.normal.values))throw new DeveloperError("geometry.attributes.normal.values is required.");if(!defined(t.st)||!defined(t.st.values))throw new DeveloperError("geometry.attributes.st.values is required.");if(!defined(r))throw new DeveloperError("geometry.indices is required.");if(r.length<2||r.length%3!=0)throw new DeveloperError("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==PrimitiveType.TRIANGLES)throw new DeveloperError("geometry.primitiveType must be PrimitiveType.TRIANGLES.");var i,n,a,o,s=e.attributes.position.values,u=e.attributes.normal.values,p=e.attributes.st.values,c=e.attributes.position.values.length/3,l=r.length,d=new Array(3*c);for(i=0;i<d.length;i++)d[i]=0;for(i=0;i<l;i+=3){var m=r[i],f=r[i+1],y=r[i+2];a=3*f,o=3*y;var v=2*m,h=2*f,b=2*y,C=s[n=3*m],g=s[n+1],P=s[n+2],T=p[v],w=p[v+1],A=p[h+1]-w,S=p[b+1]-w,E=1/((p[h]-T)*S-(p[b]-T)*A),x=(S*(s[a]-C)-A*(s[o]-C))*E,D=(S*(s[a+1]-g)-A*(s[o+1]-g))*E,I=(S*(s[a+2]-P)-A*(s[o+2]-P))*E;d[n]+=x,d[n+1]+=D,d[n+2]+=I,d[a]+=x,d[a+1]+=D,d[a+2]+=I,d[o]+=x,d[o+1]+=D,d[o+2]+=I}var L=new Float32Array(3*c),G=new Float32Array(3*c);for(i=0;i<c;i++){a=1+(n=3*i),o=n+2;var O=Cartesian3.fromArray(u,n,normalScratch),N=Cartesian3.fromArray(d,n,tScratch),M=Cartesian3.dot(O,N);Cartesian3.multiplyByScalar(O,M,normalScale),Cartesian3.normalize(Cartesian3.subtract(N,normalScale,N),N),L[n]=N.x,L[a]=N.y,L[o]=N.z,Cartesian3.normalize(Cartesian3.cross(O,N,N),N),G[n]=N.x,G[a]=N.y,G[o]=N.z}return e.attributes.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:L}),e.attributes.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:G}),e};var scratchCartesian2=new Cartesian2,toEncode1=new Cartesian3,toEncode2=new Cartesian3,toEncode3=new Cartesian3,encodeResult2=new Cartesian2;function indexTriangles(e){if(defined(e.indices))return e;var t=Geometry.computeNumberOfVertices(e);if(t<3)throw new DeveloperError("The number of vertices must be at least three.");if(t%3!=0)throw new DeveloperError("The number of vertices must be a multiple of three.");for(var r=IndexDatatype.createTypedArray(t,t),i=0;i<t;++i)r[i]=i;return e.indices=r,e}function indexTriangleFan(e){var t=Geometry.computeNumberOfVertices(e);if(t<3)throw new DeveloperError("The number of vertices must be at least three.");var r=IndexDatatype.createTypedArray(t,3*(t-2));r[0]=1,r[1]=0,r[2]=2;for(var i=3,n=3;n<t;++n)r[i++]=n-1,r[i++]=0,r[i++]=n;return e.indices=r,e.primitiveType=PrimitiveType.TRIANGLES,e}function indexTriangleStrip(e){var t=Geometry.computeNumberOfVertices(e);if(t<3)throw new DeveloperError("The number of vertices must be at least 3.");var r=IndexDatatype.createTypedArray(t,3*(t-2));r[0]=0,r[1]=1,r[2]=2,t>3&&(r[3]=0,r[4]=2,r[5]=3);for(var i=6,n=3;n<t-1;n+=2)r[i++]=n,r[i++]=n-1,r[i++]=n+1,n+2<t&&(r[i++]=n,r[i++]=n+1,r[i++]=n+2);return e.indices=r,e.primitiveType=PrimitiveType.TRIANGLES,e}function indexLines(e){if(defined(e.indices))return e;var t=Geometry.computeNumberOfVertices(e);if(t<2)throw new DeveloperError("The number of vertices must be at least two.");if(t%2!=0)throw new DeveloperError("The number of vertices must be a multiple of 2.");for(var r=IndexDatatype.createTypedArray(t,t),i=0;i<t;++i)r[i]=i;return e.indices=r,e}function indexLineStrip(e){var t=Geometry.computeNumberOfVertices(e);if(t<2)throw new DeveloperError("The number of vertices must be at least two.");var r=IndexDatatype.createTypedArray(t,2*(t-1));r[0]=0,r[1]=1;for(var i=2,n=2;n<t;++n)r[i++]=n-1,r[i++]=n;return e.indices=r,e.primitiveType=PrimitiveType.LINES,e}function indexLineLoop(e){var t=Geometry.computeNumberOfVertices(e);if(t<2)throw new DeveloperError("The number of vertices must be at least two.");var r=IndexDatatype.createTypedArray(t,2*t);r[0]=0,r[1]=1;for(var i=2,n=2;n<t;++n)r[i++]=n-1,r[i++]=n;return r[i++]=t-1,r[i]=0,e.indices=r,e.primitiveType=PrimitiveType.LINES,e}function indexPrimitive(e){switch(e.primitiveType){case PrimitiveType.TRIANGLE_FAN:return indexTriangleFan(e);case PrimitiveType.TRIANGLE_STRIP:return indexTriangleStrip(e);case PrimitiveType.TRIANGLES:return indexTriangles(e);case PrimitiveType.LINE_STRIP:return indexLineStrip(e);case PrimitiveType.LINE_LOOP:return indexLineLoop(e);case PrimitiveType.LINES:return indexLines(e)}return e}function offsetPointFromXZPlane(e,t){Math.abs(e.y)<CesiumMath.EPSILON6&&(e.y=t?-CesiumMath.EPSILON6:CesiumMath.EPSILON6)}function offsetTriangleFromXZPlane(e,t,r){if(0!==e.y&&0!==t.y&&0!==r.y)return offsetPointFromXZPlane(e,e.y<0),offsetPointFromXZPlane(t,t.y<0),void offsetPointFromXZPlane(r,r.y<0);var i=Math.abs(e.y),n=Math.abs(t.y),a=Math.abs(r.y),o=(i>n?i>a?CesiumMath.sign(e.y):CesiumMath.sign(r.y):n>a?CesiumMath.sign(t.y):CesiumMath.sign(r.y))<0;offsetPointFromXZPlane(e,o),offsetPointFromXZPlane(t,o),offsetPointFromXZPlane(r,o)}GeometryPipeline.compressVertices=function(e){if(!defined(e))throw new DeveloperError("geometry is required.");var t,r,i=e.attributes.extrudeDirection;if(defined(i)){var n=i.values;r=n.length/3;var a=new Float32Array(2*r),o=0;for(t=0;t<r;++t)Cartesian3.fromArray(n,3*t,toEncode1),Cartesian3.equals(toEncode1,Cartesian3.ZERO)?o+=2:(encodeResult2=AttributeCompression.octEncodeInRange(toEncode1,65535,encodeResult2),a[o++]=encodeResult2.x,a[o++]=encodeResult2.y);return e.attributes.compressedAttributes=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:a}),delete e.attributes.extrudeDirection,e}var s=e.attributes.normal,u=e.attributes.st,p=defined(s),c=defined(u);if(!p&&!c)return e;var l,d,m,f,y=e.attributes.tangent,v=e.attributes.bitangent,h=defined(y),b=defined(v);p&&(l=s.values),c&&(d=u.values),h&&(m=y.values),b&&(f=v.values);var C=r=(p?l.length:d.length)/(p?3:2),g=c&&p?2:1;g+=h||b?1:0;var P=new Float32Array(C*=g),T=0;for(t=0;t<r;++t){c&&(Cartesian2.fromArray(d,2*t,scratchCartesian2),P[T++]=AttributeCompression.compressTextureCoordinates(scratchCartesian2));var w=3*t;p&&defined(m)&&defined(f)?(Cartesian3.fromArray(l,w,toEncode1),Cartesian3.fromArray(m,w,toEncode2),Cartesian3.fromArray(f,w,toEncode3),AttributeCompression.octPack(toEncode1,toEncode2,toEncode3,scratchCartesian2),P[T++]=scratchCartesian2.x,P[T++]=scratchCartesian2.y):(p&&(Cartesian3.fromArray(l,w,toEncode1),P[T++]=AttributeCompression.octEncodeFloat(toEncode1)),h&&(Cartesian3.fromArray(m,w,toEncode1),P[T++]=AttributeCompression.octEncodeFloat(toEncode1)),b&&(Cartesian3.fromArray(f,w,toEncode1),P[T++]=AttributeCompression.octEncodeFloat(toEncode1)))}return e.attributes.compressedAttributes=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:g,values:P}),p&&delete e.attributes.normal,c&&delete e.attributes.st,b&&delete e.attributes.bitangent,h&&delete e.attributes.tangent,e};var c3=new Cartesian3;function getXZIntersectionOffsetPoints(e,t,r,i){Cartesian3.add(e,Cartesian3.multiplyByScalar(Cartesian3.subtract(t,e,c3),e.y/(e.y-t.y),c3),r),Cartesian3.clone(r,i),offsetPointFromXZPlane(r,!0),offsetPointFromXZPlane(i,!1)}var u1=new Cartesian3,u2=new Cartesian3,q1=new Cartesian3,q2=new Cartesian3,splitTriangleResult={positions:new Array(7),indices:new Array(9)};function splitTriangle(e,t,r){if(!(e.x>=0||t.x>=0||r.x>=0)){offsetTriangleFromXZPlane(e,t,r);var i=e.y<0,n=t.y<0,a=r.y<0,o=0;o+=i?1:0,o+=n?1:0,o+=a?1:0;var s=splitTriangleResult.indices;1===o?(s[1]=3,s[2]=4,s[5]=6,s[7]=6,s[8]=5,i?(getXZIntersectionOffsetPoints(e,t,u1,q1),getXZIntersectionOffsetPoints(e,r,u2,q2),s[0]=0,s[3]=1,s[4]=2,s[6]=1):n?(getXZIntersectionOffsetPoints(t,r,u1,q1),getXZIntersectionOffsetPoints(t,e,u2,q2),s[0]=1,s[3]=2,s[4]=0,s[6]=2):a&&(getXZIntersectionOffsetPoints(r,e,u1,q1),getXZIntersectionOffsetPoints(r,t,u2,q2),s[0]=2,s[3]=0,s[4]=1,s[6]=0)):2===o&&(s[2]=4,s[4]=4,s[5]=3,s[7]=5,s[8]=6,i?n?a||(getXZIntersectionOffsetPoints(r,e,u1,q1),getXZIntersectionOffsetPoints(r,t,u2,q2),s[0]=0,s[1]=1,s[3]=0,s[6]=2):(getXZIntersectionOffsetPoints(t,r,u1,q1),getXZIntersectionOffsetPoints(t,e,u2,q2),s[0]=2,s[1]=0,s[3]=2,s[6]=1):(getXZIntersectionOffsetPoints(e,t,u1,q1),getXZIntersectionOffsetPoints(e,r,u2,q2),s[0]=1,s[1]=2,s[3]=1,s[6]=0));var u=splitTriangleResult.positions;return u[0]=e,u[1]=t,u[2]=r,u.length=3,1!==o&&2!==o||(u[3]=u1,u[4]=u2,u[5]=q1,u[6]=q2,u.length=7),splitTriangleResult}}function updateGeometryAfterSplit(e,t){var r=e.attributes;if(0!==r.position.values.length){for(var i in r)if(r.hasOwnProperty(i)&&defined(r[i])&&defined(r[i].values)){var n=r[i];n.values=ComponentDatatype.createTypedArray(n.componentDatatype,n.values)}var a=Geometry.computeNumberOfVertices(e);return e.indices=IndexDatatype.createTypedArray(a,e.indices),t&&(e.boundingSphere=BoundingSphere.fromVertices(r.position.values)),e}}function copyGeometryForSplit(e){var t=e.attributes,r={};for(var i in t)if(t.hasOwnProperty(i)&&defined(t[i])&&defined(t[i].values)){var n=t[i];r[i]=new GeometryAttribute({componentDatatype:n.componentDatatype,componentsPerAttribute:n.componentsPerAttribute,normalize:n.normalize,values:[]})}return new Geometry({attributes:r,indices:[],primitiveType:e.primitiveType})}function updateInstanceAfterSplit(e,t,r){var i=defined(e.geometry.boundingSphere);t=updateGeometryAfterSplit(t,i),r=updateGeometryAfterSplit(r,i),defined(r)&&!defined(t)?e.geometry=r:!defined(r)&&defined(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=r,e.geometry=void 0)}function generateBarycentricInterpolateFunction(e,t){var r=new e,i=new e,n=new e;return function(a,o,s,u,p,c,l,d){var m=e.fromArray(p,a*t,r),f=e.fromArray(p,o*t,i),y=e.fromArray(p,s*t,n);e.multiplyByScalar(m,u.x,m),e.multiplyByScalar(f,u.y,f),e.multiplyByScalar(y,u.z,y);var v=e.add(m,f,m);e.add(v,y,v),d&&e.normalize(v,v),e.pack(v,c,l*t)}}var interpolateAndPackCartesian4=generateBarycentricInterpolateFunction(Cartesian4,4),interpolateAndPackCartesian3=generateBarycentricInterpolateFunction(Cartesian3,3),interpolateAndPackCartesian2=generateBarycentricInterpolateFunction(Cartesian2,2),interpolateAndPackBoolean=function(e,t,r,i,n,a,o){var s=n[e]*i.x,u=n[t]*i.y,p=n[r]*i.z;a[o]=s+u+p>CesiumMath.EPSILON6?1:0},p0Scratch=new Cartesian3,p1Scratch=new Cartesian3,p2Scratch=new Cartesian3,barycentricScratch=new Cartesian3;function computeTriangleAttributes(e,t,r,i,n,a,o,s,u,p,c,l,d,m,f,y){if(defined(a)||defined(o)||defined(s)||defined(u)||defined(p)||0!==m){var v=Cartesian3.fromArray(n,3*e,p0Scratch),h=Cartesian3.fromArray(n,3*t,p1Scratch),b=Cartesian3.fromArray(n,3*r,p2Scratch),C=barycentricCoordinates(i,v,h,b,barycentricScratch);if(defined(C)){if(defined(a)&&interpolateAndPackCartesian3(e,t,r,C,a,l.normal.values,y,!0),defined(p)){var g,P=Cartesian3.fromArray(p,3*e,p0Scratch),T=Cartesian3.fromArray(p,3*t,p1Scratch),w=Cartesian3.fromArray(p,3*r,p2Scratch);Cartesian3.multiplyByScalar(P,C.x,P),Cartesian3.multiplyByScalar(T,C.y,T),Cartesian3.multiplyByScalar(w,C.z,w),Cartesian3.equals(P,Cartesian3.ZERO)&&Cartesian3.equals(T,Cartesian3.ZERO)&&Cartesian3.equals(w,Cartesian3.ZERO)?((g=p0Scratch).x=0,g.y=0,g.z=0):(g=Cartesian3.add(P,T,P),Cartesian3.add(g,w,g),Cartesian3.normalize(g,g)),Cartesian3.pack(g,l.extrudeDirection.values,3*y)}if(defined(c)&&interpolateAndPackBoolean(e,t,r,C,c,l.applyOffset.values,y),defined(o)&&interpolateAndPackCartesian3(e,t,r,C,o,l.tangent.values,y,!0),defined(s)&&interpolateAndPackCartesian3(e,t,r,C,s,l.bitangent.values,y,!0),defined(u)&&interpolateAndPackCartesian2(e,t,r,C,u,l.st.values,y),m>0)for(var A=0;A<m;A++){var S=d[A];genericInterpolate(e,t,r,C,y,f[S],l[S])}}}}function genericInterpolate(e,t,r,i,n,a,o){var s=a.componentsPerAttribute,u=a.values,p=o.values;switch(s){case 4:interpolateAndPackCartesian4(e,t,r,i,u,p,n,!1);break;case 3:interpolateAndPackCartesian3(e,t,r,i,u,p,n,!1);break;case 2:interpolateAndPackCartesian2(e,t,r,i,u,p,n,!1);break;default:p[n]=u[e]*i.x+u[t]*i.y+u[r]*i.z}}function insertSplitPoint(e,t,r,i,n,a){var o=e.position.values.length/3;if(-1!==n){var s=i[n],u=r[s];return-1===u?(r[s]=o,e.position.values.push(a.x,a.y,a.z),t.push(o),o):(t.push(u),u)}return e.position.values.push(a.x,a.y,a.z),t.push(o),o}var NAMED_ATTRIBUTES={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function splitLongitudeTriangles(e){var t=e.geometry,r=t.attributes,i=r.position.values,n=defined(r.normal)?r.normal.values:void 0,a=defined(r.bitangent)?r.bitangent.values:void 0,o=defined(r.tangent)?r.tangent.values:void 0,s=defined(r.st)?r.st.values:void 0,u=defined(r.extrudeDirection)?r.extrudeDirection.values:void 0,p=defined(r.applyOffset)?r.applyOffset.values:void 0,c=t.indices,l=[];for(var d in r)r.hasOwnProperty(d)&&!NAMED_ATTRIBUTES[d]&&defined(r[d])&&l.push(d);var m,f,y,v,h=l.length,b=copyGeometryForSplit(t),C=copyGeometryForSplit(t),g=[];g.length=i.length/3;var P=[];for(P.length=i.length/3,v=0;v<g.length;++v)g[v]=-1,P[v]=-1;var T=c.length;for(v=0;v<T;v+=3){var w=c[v],A=c[v+1],S=c[v+2],E=Cartesian3.fromArray(i,3*w),x=Cartesian3.fromArray(i,3*A),D=Cartesian3.fromArray(i,3*S),I=splitTriangle(E,x,D);if(defined(I)&&I.positions.length>3)for(var L=I.positions,G=I.indices,O=G.length,N=0;N<O;++N){var M=G[N],z=L[M];z.y<0?(m=C.attributes,f=C.indices,y=g):(m=b.attributes,f=b.indices,y=P),computeTriangleAttributes(w,A,S,z,i,n,o,a,s,u,p,m,l,h,r,insertSplitPoint(m,f,y,c,M<3?v+M:-1,z))}else defined(I)&&(E=I.positions[0],x=I.positions[1],D=I.positions[2]),E.y<0?(m=C.attributes,f=C.indices,y=g):(m=b.attributes,f=b.indices,y=P),computeTriangleAttributes(w,A,S,E,i,n,o,a,s,u,p,m,l,h,r,insertSplitPoint(m,f,y,c,v,E)),computeTriangleAttributes(w,A,S,x,i,n,o,a,s,u,p,m,l,h,r,insertSplitPoint(m,f,y,c,v+1,x)),computeTriangleAttributes(w,A,S,D,i,n,o,a,s,u,p,m,l,h,r,insertSplitPoint(m,f,y,c,v+2,D))}updateInstanceAfterSplit(e,C,b)}var xzPlane=Plane.fromPointNormal(Cartesian3.ZERO,Cartesian3.UNIT_Y),offsetScratch=new Cartesian3,offsetPointScratch=new Cartesian3;function computeLineAttributes(e,t,r,i,n,a,o){if(defined(o)){var s=Cartesian3.fromArray(i,3*e,p0Scratch);Cartesian3.equalsEpsilon(s,r,CesiumMath.EPSILON10)?a.applyOffset.values[n]=o[e]:a.applyOffset.values[n]=o[t]}}function splitLongitudeLines(e){var t,r=e.geometry,i=r.attributes,n=i.position.values,a=defined(i.applyOffset)?i.applyOffset.values:void 0,o=r.indices,s=copyGeometryForSplit(r),u=copyGeometryForSplit(r),p=o.length,c=[];c.length=n.length/3;var l=[];for(l.length=n.length/3,t=0;t<c.length;++t)c[t]=-1,l[t]=-1;for(t=0;t<p;t+=2){var d=o[t],m=o[t+1],f=Cartesian3.fromArray(n,3*d,p0Scratch),y=Cartesian3.fromArray(n,3*m,p1Scratch);Math.abs(f.y)<CesiumMath.EPSILON6&&(f.y<0?f.y=-CesiumMath.EPSILON6:f.y=CesiumMath.EPSILON6),Math.abs(y.y)<CesiumMath.EPSILON6&&(y.y<0?y.y=-CesiumMath.EPSILON6:y.y=CesiumMath.EPSILON6);var v=s.attributes,h=s.indices,b=l,C=u.attributes,g=u.indices,P=c,T=IntersectionTests.lineSegmentPlane(f,y,xzPlane,p2Scratch);if(defined(T)){var w=Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y,5*CesiumMath.EPSILON9,offsetScratch);f.y<0&&(Cartesian3.negate(w,w),v=u.attributes,h=u.indices,b=c,C=s.attributes,g=s.indices,P=l);var A=Cartesian3.add(T,w,offsetPointScratch);computeLineAttributes(d,m,f,n,insertSplitPoint(v,h,b,o,t,f),v,a),computeLineAttributes(d,m,A,n,insertSplitPoint(v,h,b,o,-1,A),v,a),Cartesian3.negate(w,w),Cartesian3.add(T,w,A),computeLineAttributes(d,m,A,n,insertSplitPoint(C,g,P,o,-1,A),C,a),computeLineAttributes(d,m,y,n,insertSplitPoint(C,g,P,o,t+1,y),C,a)}else{var S,E,x;f.y<0?(S=u.attributes,E=u.indices,x=c):(S=s.attributes,E=s.indices,x=l),computeLineAttributes(d,m,f,n,insertSplitPoint(S,E,x,o,t,f),S,a),computeLineAttributes(d,m,y,n,insertSplitPoint(S,E,x,o,t+1,y),S,a)}}updateInstanceAfterSplit(e,u,s)}var cartesian2Scratch0=new Cartesian2,cartesian2Scratch1=new Cartesian2,cartesian3Scratch0=new Cartesian3,cartesian3Scratch2=new Cartesian3,cartesian3Scratch3=new Cartesian3,cartesian3Scratch4=new Cartesian3,cartesian3Scratch5=new Cartesian3,cartesian3Scratch6=new Cartesian3,cartesian4Scratch0=new Cartesian4;function updateAdjacencyAfterSplit(e){for(var t=e.attributes,r=t.position.values,i=t.prevPosition.values,n=t.nextPosition.values,a=r.length,o=0;o<a;o+=3){var s=Cartesian3.unpack(r,o,cartesian3Scratch0);if(!(s.x>0)){var u=Cartesian3.unpack(i,o,cartesian3Scratch2);(s.y<0&&u.y>0||s.y>0&&u.y<0)&&(o-3>0?(i[o]=r[o-3],i[o+1]=r[o-2],i[o+2]=r[o-1]):Cartesian3.pack(s,i,o));var p=Cartesian3.unpack(n,o,cartesian3Scratch3);(s.y<0&&p.y>0||s.y>0&&p.y<0)&&(o+3<a?(n[o]=r[o+3],n[o+1]=r[o+4],n[o+2]=r[o+5]):Cartesian3.pack(s,n,o))}}}var offsetScalar=5*CesiumMath.EPSILON9,coplanarOffset=CesiumMath.EPSILON6;function splitLongitudePolyline(e){var t,r,i,n=e.geometry,a=n.attributes,o=a.position.values,s=a.prevPosition.values,u=a.nextPosition.values,p=a.expandAndWidth.values,c=defined(a.st)?a.st.values:void 0,l=defined(a.color)?a.color.values:void 0,d=copyGeometryForSplit(n),m=copyGeometryForSplit(n),f=!1,y=o.length/3;for(t=0;t<y;t+=4){var v=t,h=t+2,b=Cartesian3.fromArray(o,3*v,cartesian3Scratch0),C=Cartesian3.fromArray(o,3*h,cartesian3Scratch2);if(Math.abs(b.y)<coplanarOffset)for(b.y=coplanarOffset*(C.y<0?-1:1),o[3*t+1]=b.y,o[3*(t+1)+1]=b.y,r=3*v;r<3*v+12;r+=3)s[r]=o[3*t],s[r+1]=o[3*t+1],s[r+2]=o[3*t+2];if(Math.abs(C.y)<coplanarOffset)for(C.y=coplanarOffset*(b.y<0?-1:1),o[3*(t+2)+1]=C.y,o[3*(t+3)+1]=C.y,r=3*v;r<3*v+12;r+=3)u[r]=o[3*(t+2)],u[r+1]=o[3*(t+2)+1],u[r+2]=o[3*(t+2)+2];var g=d.attributes,P=d.indices,T=m.attributes,w=m.indices,A=IntersectionTests.lineSegmentPlane(b,C,xzPlane,cartesian3Scratch4);if(defined(A)){f=!0;var S=Cartesian3.multiplyByScalar(Cartesian3.UNIT_Y,offsetScalar,cartesian3Scratch5);b.y<0&&(Cartesian3.negate(S,S),g=m.attributes,P=m.indices,T=d.attributes,w=d.indices);var E=Cartesian3.add(A,S,cartesian3Scratch6);g.position.values.push(b.x,b.y,b.z,b.x,b.y,b.z),g.position.values.push(E.x,E.y,E.z),g.position.values.push(E.x,E.y,E.z),g.prevPosition.values.push(s[3*v],s[3*v+1],s[3*v+2]),g.prevPosition.values.push(s[3*v+3],s[3*v+4],s[3*v+5]),g.prevPosition.values.push(b.x,b.y,b.z,b.x,b.y,b.z),g.nextPosition.values.push(E.x,E.y,E.z),g.nextPosition.values.push(E.x,E.y,E.z),g.nextPosition.values.push(E.x,E.y,E.z),g.nextPosition.values.push(E.x,E.y,E.z),Cartesian3.negate(S,S),Cartesian3.add(A,S,E),T.position.values.push(E.x,E.y,E.z),T.position.values.push(E.x,E.y,E.z),T.position.values.push(C.x,C.y,C.z,C.x,C.y,C.z),T.prevPosition.values.push(E.x,E.y,E.z),T.prevPosition.values.push(E.x,E.y,E.z),T.prevPosition.values.push(E.x,E.y,E.z),T.prevPosition.values.push(E.x,E.y,E.z),T.nextPosition.values.push(C.x,C.y,C.z,C.x,C.y,C.z),T.nextPosition.values.push(u[3*h],u[3*h+1],u[3*h+2]),T.nextPosition.values.push(u[3*h+3],u[3*h+4],u[3*h+5]);var x=Cartesian2.fromArray(p,2*v,cartesian2Scratch0),D=Math.abs(x.y);g.expandAndWidth.values.push(-1,D,1,D),g.expandAndWidth.values.push(-1,-D,1,-D),T.expandAndWidth.values.push(-1,D,1,D),T.expandAndWidth.values.push(-1,-D,1,-D);var I=Cartesian3.magnitudeSquared(Cartesian3.subtract(A,b,cartesian3Scratch3));if(I/=Cartesian3.magnitudeSquared(Cartesian3.subtract(C,b,cartesian3Scratch3)),defined(l)){var L=Cartesian4.fromArray(l,4*v,cartesian4Scratch0),G=Cartesian4.fromArray(l,4*h,cartesian4Scratch0),O=CesiumMath.lerp(L.x,G.x,I),N=CesiumMath.lerp(L.y,G.y,I),M=CesiumMath.lerp(L.z,G.z,I),z=CesiumMath.lerp(L.w,G.w,I);for(r=4*v;r<4*v+8;++r)g.color.values.push(l[r]);for(g.color.values.push(O,N,M,z),g.color.values.push(O,N,M,z),T.color.values.push(O,N,M,z),T.color.values.push(O,N,M,z),r=4*h;r<4*h+8;++r)T.color.values.push(l[r])}if(defined(c)){var q=Cartesian2.fromArray(c,2*v,cartesian2Scratch0),F=Cartesian2.fromArray(c,2*(t+3),cartesian2Scratch1),R=CesiumMath.lerp(q.x,F.x,I);for(r=2*v;r<2*v+4;++r)g.st.values.push(c[r]);for(g.st.values.push(R,q.y),g.st.values.push(R,F.y),T.st.values.push(R,q.y),T.st.values.push(R,F.y),r=2*h;r<2*h+4;++r)T.st.values.push(c[r])}i=g.position.values.length/3-4,P.push(i,i+2,i+1),P.push(i+1,i+2,i+3),i=T.position.values.length/3-4,w.push(i,i+2,i+1),w.push(i+1,i+2,i+3)}else{var j,B;for(b.y<0?(j=m.attributes,B=m.indices):(j=d.attributes,B=d.indices),j.position.values.push(b.x,b.y,b.z),j.position.values.push(b.x,b.y,b.z),j.position.values.push(C.x,C.y,C.z),j.position.values.push(C.x,C.y,C.z),r=3*t;r<3*t+12;++r)j.prevPosition.values.push(s[r]),j.nextPosition.values.push(u[r]);for(r=2*t;r<2*t+8;++r)j.expandAndWidth.values.push(p[r]),defined(c)&&j.st.values.push(c[r]);if(defined(l))for(r=4*t;r<4*t+16;++r)j.color.values.push(l[r]);i=j.position.values.length/3-4,B.push(i,i+2,i+1),B.push(i+1,i+2,i+3)}}f&&(updateAdjacencyAfterSplit(m),updateAdjacencyAfterSplit(d)),updateInstanceAfterSplit(e,m,d)}GeometryPipeline.splitLongitude=function(e){if(!defined(e))throw new DeveloperError("instance is required.");var t=e.geometry,r=t.boundingSphere;if(defined(r)&&(r.center.x-r.radius>0||BoundingSphere.intersectPlane(r,Plane.ORIGIN_ZX_PLANE)!==Intersect.INTERSECTING))return e;if(t.geometryType!==GeometryType.NONE)switch(t.geometryType){case GeometryType.POLYLINES:splitLongitudePolyline(e);break;case GeometryType.TRIANGLES:splitLongitudeTriangles(e);break;case GeometryType.LINES:splitLongitudeLines(e)}else indexPrimitive(t),t.primitiveType===PrimitiveType.TRIANGLES?splitLongitudeTriangles(e):t.primitiveType===PrimitiveType.LINES&&splitLongitudeLines(e);return e};export default GeometryPipeline;