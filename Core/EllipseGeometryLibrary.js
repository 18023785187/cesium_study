import Cartesian3 from"./Cartesian3.js";import CesiumMath from"./Math.js";import Matrix3 from"./Matrix3.js";import Quaternion from"./Quaternion.js";var EllipseGeometryLibrary={},rotAxis=new Cartesian3,tempVec=new Cartesian3,unitQuat=new Quaternion,rotMtx=new Matrix3;function pointOnEllipsoid(a,t,r,i,e,n,s,o,c,l){var C=a+t;Cartesian3.multiplyByScalar(i,Math.cos(C),rotAxis),Cartesian3.multiplyByScalar(r,Math.sin(C),tempVec),Cartesian3.add(rotAxis,tempVec,rotAxis);var h=Math.cos(a);h*=h;var m=Math.sin(a);m*=m;var u=n/Math.sqrt(s*h+e*m)/o;return Quaternion.fromAxisAngle(rotAxis,u,unitQuat),Matrix3.fromQuaternion(unitQuat,rotMtx),Matrix3.multiplyByVector(rotMtx,c,l),Cartesian3.normalize(l,l),Cartesian3.multiplyByScalar(l,o,l),l}var scratchCartesian1=new Cartesian3,scratchCartesian2=new Cartesian3,scratchCartesian3=new Cartesian3,scratchNormal=new Cartesian3;EllipseGeometryLibrary.raisePositionsToHeight=function(a,t,r){for(var i=t.ellipsoid,e=t.height,n=t.extrudedHeight,s=r?a.length/3*2:a.length/3,o=new Float64Array(3*s),c=a.length,l=r?c:0,C=0;C<c;C+=3){var h=C+1,m=C+2,u=Cartesian3.fromArray(a,C,scratchCartesian1);i.scaleToGeodeticSurface(u,u);var y=Cartesian3.clone(u,scratchCartesian2),p=i.geodeticSurfaceNormal(u,scratchNormal),x=Cartesian3.multiplyByScalar(p,e,scratchCartesian3);Cartesian3.add(u,x,u),r&&(Cartesian3.multiplyByScalar(p,n,x),Cartesian3.add(y,x,y),o[C+l]=y.x,o[h+l]=y.y,o[m+l]=y.z),o[C]=u.x,o[h]=u.y,o[m]=u.z}return o};var unitPosScratch=new Cartesian3,eastVecScratch=new Cartesian3,northVecScratch=new Cartesian3;EllipseGeometryLibrary.computeEllipsePositions=function(a,t,r){var i=a.semiMinorAxis,e=a.semiMajorAxis,n=a.rotation,s=a.center,o=8*a.granularity,c=i*i,l=e*e,C=e*i,h=Cartesian3.magnitude(s),m=Cartesian3.normalize(s,unitPosScratch),u=Cartesian3.cross(Cartesian3.UNIT_Z,s,eastVecScratch);u=Cartesian3.normalize(u,u);var y=Cartesian3.cross(m,u,northVecScratch),p=1+Math.ceil(CesiumMath.PI_OVER_TWO/o),x=CesiumMath.PI_OVER_TWO/(p-1),M=CesiumMath.PI_OVER_TWO-p*x;M<0&&(p-=Math.ceil(Math.abs(M)/x));var O,d,f,E,z,_=t?new Array(p*(p+2)*2*3):void 0,v=0,P=scratchCartesian1,V=scratchCartesian2,w=4*p*3,A=w-1,S=0,I=r?new Array(w):void 0;for(P=pointOnEllipsoid(M=CesiumMath.PI_OVER_TWO,n,y,u,c,C,l,h,m,P),t&&(_[v++]=P.x,_[v++]=P.y,_[v++]=P.z),r&&(I[A--]=P.z,I[A--]=P.y,I[A--]=P.x),M=CesiumMath.PI_OVER_TWO-x,O=1;O<p+1;++O){if(P=pointOnEllipsoid(M,n,y,u,c,C,l,h,m,P),V=pointOnEllipsoid(Math.PI-M,n,y,u,c,C,l,h,m,V),t){for(_[v++]=P.x,_[v++]=P.y,_[v++]=P.z,f=2*O+2,d=1;d<f-1;++d)E=d/(f-1),z=Cartesian3.lerp(P,V,E,scratchCartesian3),_[v++]=z.x,_[v++]=z.y,_[v++]=z.z;_[v++]=V.x,_[v++]=V.y,_[v++]=V.z}r&&(I[A--]=P.z,I[A--]=P.y,I[A--]=P.x,I[S++]=V.x,I[S++]=V.y,I[S++]=V.z),M=CesiumMath.PI_OVER_TWO-(O+1)*x}for(O=p;O>1;--O){if(P=pointOnEllipsoid(-(M=CesiumMath.PI_OVER_TWO-(O-1)*x),n,y,u,c,C,l,h,m,P),V=pointOnEllipsoid(M+Math.PI,n,y,u,c,C,l,h,m,V),t){for(_[v++]=P.x,_[v++]=P.y,_[v++]=P.z,f=2*(O-1)+2,d=1;d<f-1;++d)E=d/(f-1),z=Cartesian3.lerp(P,V,E,scratchCartesian3),_[v++]=z.x,_[v++]=z.y,_[v++]=z.z;_[v++]=V.x,_[v++]=V.y,_[v++]=V.z}r&&(I[A--]=P.z,I[A--]=P.y,I[A--]=P.x,I[S++]=V.x,I[S++]=V.y,I[S++]=V.z)}P=pointOnEllipsoid(-(M=CesiumMath.PI_OVER_TWO),n,y,u,c,C,l,h,m,P);var T={};return t&&(_[v++]=P.x,_[v++]=P.y,_[v++]=P.z,T.positions=_,T.numPts=p),r&&(I[A--]=P.z,I[A--]=P.y,I[A--]=P.x,T.outerPositions=I),T};export default EllipseGeometryLibrary;