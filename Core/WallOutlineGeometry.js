import BoundingSphere from"./BoundingSphere.js";import Cartesian3 from"./Cartesian3.js";import ComponentDatatype from"./ComponentDatatype.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import Ellipsoid from"./Ellipsoid.js";import Geometry from"./Geometry.js";import GeometryAttribute from"./GeometryAttribute.js";import GeometryAttributes from"./GeometryAttributes.js";import IndexDatatype from"./IndexDatatype.js";import CesiumMath from"./Math.js";import PrimitiveType from"./PrimitiveType.js";import WallGeometryLibrary from"./WallGeometryLibrary.js";var scratchCartesian3Position1=new Cartesian3,scratchCartesian3Position2=new Cartesian3;function WallOutlineGeometry(e){var i=(e=defaultValue(e,defaultValue.EMPTY_OBJECT)).positions,t=e.maximumHeights,r=e.minimumHeights;if(!defined(i))throw new DeveloperError("options.positions is required.");if(defined(t)&&t.length!==i.length)throw new DeveloperError("options.positions and options.maximumHeights must have the same length.");if(defined(r)&&r.length!==i.length)throw new DeveloperError("options.positions and options.minimumHeights must have the same length.");var o=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),a=defaultValue(e.ellipsoid,Ellipsoid.WGS84);this._positions=i,this._minimumHeights=r,this._maximumHeights=t,this._granularity=o,this._ellipsoid=Ellipsoid.clone(a),this._workerName="createWallOutlineGeometry";var n=1+i.length*Cartesian3.packedLength+2;defined(r)&&(n+=r.length),defined(t)&&(n+=t.length),this.packedLength=n+Ellipsoid.packedLength+1}WallOutlineGeometry.pack=function(e,i,t){if(!defined(e))throw new DeveloperError("value is required");if(!defined(i))throw new DeveloperError("array is required");var r;t=defaultValue(t,0);var o=e._positions,a=o.length;for(i[t++]=a,r=0;r<a;++r,t+=Cartesian3.packedLength)Cartesian3.pack(o[r],i,t);var n=e._minimumHeights;if(a=defined(n)?n.length:0,i[t++]=a,defined(n))for(r=0;r<a;++r)i[t++]=n[r];var s=e._maximumHeights;if(a=defined(s)?s.length:0,i[t++]=a,defined(s))for(r=0;r<a;++r)i[t++]=s[r];return Ellipsoid.pack(e._ellipsoid,i,t),i[t+=Ellipsoid.packedLength]=e._granularity,i};var scratchEllipsoid=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchOptions={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:scratchEllipsoid,granularity:void 0};WallOutlineGeometry.unpack=function(e,i,t){if(!defined(e))throw new DeveloperError("array is required");var r;i=defaultValue(i,0);var o,a,n=e[i++],s=new Array(n);for(r=0;r<n;++r,i+=Cartesian3.packedLength)s[r]=Cartesian3.unpack(e,i);if((n=e[i++])>0)for(o=new Array(n),r=0;r<n;++r)o[r]=e[i++];if((n=e[i++])>0)for(a=new Array(n),r=0;r<n;++r)a[r]=e[i++];var l=Ellipsoid.unpack(e,i,scratchEllipsoid),m=e[i+=Ellipsoid.packedLength];return defined(t)?(t._positions=s,t._minimumHeights=o,t._maximumHeights=a,t._ellipsoid=Ellipsoid.clone(l,t._ellipsoid),t._granularity=m,t):(scratchOptions.positions=s,scratchOptions.minimumHeights=o,scratchOptions.maximumHeights=a,scratchOptions.granularity=m,new WallOutlineGeometry(scratchOptions))},WallOutlineGeometry.fromConstantHeights=function(e){var i,t,r=(e=defaultValue(e,defaultValue.EMPTY_OBJECT)).positions;if(!defined(r))throw new DeveloperError("options.positions is required.");var o=e.minimumHeight,a=e.maximumHeight,n=defined(o),s=defined(a);if(n||s){var l=r.length;i=n?new Array(l):void 0,t=s?new Array(l):void 0;for(var m=0;m<l;++m)n&&(i[m]=o),s&&(t[m]=a)}return new WallOutlineGeometry({positions:r,maximumHeights:t,minimumHeights:i,ellipsoid:e.ellipsoid})},WallOutlineGeometry.createGeometry=function(e){var i=e._positions,t=e._minimumHeights,r=e._maximumHeights,o=e._granularity,a=e._ellipsoid,n=WallGeometryLibrary.computePositions(a,i,r,t,o,!1);if(defined(n)){var s,l=n.bottomPositions,m=n.topPositions,p=m.length,d=2*p,u=new Float64Array(d),h=0;for(p/=3,s=0;s<p;++s){var f=3*s,c=Cartesian3.fromArray(m,f,scratchCartesian3Position1),y=Cartesian3.fromArray(l,f,scratchCartesian3Position2);u[h++]=y.x,u[h++]=y.y,u[h++]=y.z,u[h++]=c.x,u[h++]=c.y,u[h++]=c.z}var g=new GeometryAttributes({position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:u})}),v=d/3;d=2*v-4+v;var E=IndexDatatype.createTypedArray(v,d),w=0;for(s=0;s<v-2;s+=2){var C=s,_=s+2,G=Cartesian3.fromArray(u,3*C,scratchCartesian3Position1),H=Cartesian3.fromArray(u,3*_,scratchCartesian3Position2);if(!Cartesian3.equalsEpsilon(G,H,CesiumMath.EPSILON10)){var A=s+1,D=s+3;E[w++]=A,E[w++]=C,E[w++]=A,E[w++]=D,E[w++]=C,E[w++]=_}}return E[w++]=v-2,E[w++]=v-1,new Geometry({attributes:g,indices:E,primitiveType:PrimitiveType.LINES,boundingSphere:new BoundingSphere.fromVertices(u)})}};export default WallOutlineGeometry;