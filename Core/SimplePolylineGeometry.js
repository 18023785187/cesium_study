import ArcType from"./ArcType.js";import BoundingSphere from"./BoundingSphere.js";import Cartesian3 from"./Cartesian3.js";import Color from"./Color.js";import ComponentDatatype from"./ComponentDatatype.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import Ellipsoid from"./Ellipsoid.js";import Geometry from"./Geometry.js";import GeometryAttribute from"./GeometryAttribute.js";import GeometryAttributes from"./GeometryAttributes.js";import IndexDatatype from"./IndexDatatype.js";import CesiumMath from"./Math.js";import PolylinePipeline from"./PolylinePipeline.js";import PrimitiveType from"./PrimitiveType.js";function interpolateColors(e,r,o,t,i,a,l){var n,p=PolylinePipeline.numberOfPoints(e,r,i),s=o.red,y=o.green,f=o.blue,d=o.alpha,c=t.red,m=t.green,u=t.blue,h=t.alpha;if(Color.equals(o,t)){for(n=0;n<p;n++)a[l++]=Color.floatToByte(s),a[l++]=Color.floatToByte(y),a[l++]=Color.floatToByte(f),a[l++]=Color.floatToByte(d);return l}var C=(c-s)/p,g=(m-y)/p,v=(u-f)/p,T=(h-d)/p,A=l;for(n=0;n<p;n++)a[A++]=Color.floatToByte(s+n*C),a[A++]=Color.floatToByte(y+n*g),a[A++]=Color.floatToByte(f+n*v),a[A++]=Color.floatToByte(d+n*T);return A}function SimplePolylineGeometry(e){var r=(e=defaultValue(e,defaultValue.EMPTY_OBJECT)).positions,o=e.colors,t=defaultValue(e.colorsPerVertex,!1);if(!defined(r)||r.length<2)throw new DeveloperError("At least two positions are required.");if(defined(o)&&(t&&o.length<r.length||!t&&o.length<r.length-1))throw new DeveloperError("colors has an invalid length.");this._positions=r,this._colors=o,this._colorsPerVertex=t,this._arcType=defaultValue(e.arcType,ArcType.GEODESIC),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";var i=1+r.length*Cartesian3.packedLength;i+=defined(o)?1+o.length*Color.packedLength:1,this.packedLength=i+Ellipsoid.packedLength+3}SimplePolylineGeometry.pack=function(e,r,o){if(!defined(e))throw new DeveloperError("value is required");if(!defined(r))throw new DeveloperError("array is required");var t;o=defaultValue(o,0);var i=e._positions,a=i.length;for(r[o++]=a,t=0;t<a;++t,o+=Cartesian3.packedLength)Cartesian3.pack(i[t],r,o);var l=e._colors;for(a=defined(l)?l.length:0,r[o++]=a,t=0;t<a;++t,o+=Color.packedLength)Color.pack(l[t],r,o);return Ellipsoid.pack(e._ellipsoid,r,o),o+=Ellipsoid.packedLength,r[o++]=e._colorsPerVertex?1:0,r[o++]=e._arcType,r[o]=e._granularity,r},SimplePolylineGeometry.unpack=function(e,r,o){if(!defined(e))throw new DeveloperError("array is required");var t;r=defaultValue(r,0);var i=e[r++],a=new Array(i);for(t=0;t<i;++t,r+=Cartesian3.packedLength)a[t]=Cartesian3.unpack(e,r);var l=(i=e[r++])>0?new Array(i):void 0;for(t=0;t<i;++t,r+=Color.packedLength)l[t]=Color.unpack(e,r);var n=Ellipsoid.unpack(e,r);r+=Ellipsoid.packedLength;var p=1===e[r++],s=e[r++],y=e[r];return defined(o)?(o._positions=a,o._colors=l,o._ellipsoid=n,o._colorsPerVertex=p,o._arcType=s,o._granularity=y,o):new SimplePolylineGeometry({positions:a,colors:l,ellipsoid:n,colorsPerVertex:p,arcType:s,granularity:y})};var scratchArray1=new Array(2),scratchArray2=new Array(2),generateArcOptionsScratch={positions:scratchArray1,height:scratchArray2,ellipsoid:void 0,minDistance:void 0,granularity:void 0};SimplePolylineGeometry.createGeometry=function(e){var r,o,t,i,a,l=e._positions,n=e._colors,p=e._colorsPerVertex,s=e._arcType,y=e._granularity,f=e._ellipsoid,d=CesiumMath.chordLength(y,f.maximumRadius),c=defined(n)&&!p,m=l.length,u=0;if(s===ArcType.GEODESIC||s===ArcType.RHUMB){var h,C,g;s===ArcType.GEODESIC?(h=CesiumMath.chordLength(y,f.maximumRadius),C=PolylinePipeline.numberOfPoints,g=PolylinePipeline.generateArc):(h=y,C=PolylinePipeline.numberOfPointsRhumbLine,g=PolylinePipeline.generateRhumbArc);var v=PolylinePipeline.extractHeights(l,f),T=generateArcOptionsScratch;if(s===ArcType.GEODESIC?T.minDistance=d:T.granularity=y,T.ellipsoid=f,c){var A=0;for(r=0;r<m-1;r++)A+=C(l[r],l[r+1],h)+1;o=new Float64Array(3*A),i=new Uint8Array(4*A),T.positions=scratchArray1,T.height=scratchArray2;var P=0;for(r=0;r<m-1;++r){scratchArray1[0]=l[r],scratchArray1[1]=l[r+1],scratchArray2[0]=v[r],scratchArray2[1]=v[r+1];var E=g(T);if(defined(n)){var B=E.length/3;a=n[r];for(var _=0;_<B;++_)i[P++]=Color.floatToByte(a.red),i[P++]=Color.floatToByte(a.green),i[P++]=Color.floatToByte(a.blue),i[P++]=Color.floatToByte(a.alpha)}o.set(E,u),u+=E.length}}else if(T.positions=l,T.height=v,o=new Float64Array(g(T)),defined(n)){for(i=new Uint8Array(o.length/3*4),r=0;r<m-1;++r)u=interpolateColors(l[r],l[r+1],n[r],n[r+1],d,i,u);var w=n[m-1];i[u++]=Color.floatToByte(w.red),i[u++]=Color.floatToByte(w.green),i[u++]=Color.floatToByte(w.blue),i[u++]=Color.floatToByte(w.alpha)}}else{t=c?2*m-2:m,o=new Float64Array(3*t),i=defined(n)?new Uint8Array(4*t):void 0;var D=0,G=0;for(r=0;r<m;++r){var b=l[r];if(c&&r>0&&(Cartesian3.pack(b,o,D),D+=3,a=n[r-1],i[G++]=Color.floatToByte(a.red),i[G++]=Color.floatToByte(a.green),i[G++]=Color.floatToByte(a.blue),i[G++]=Color.floatToByte(a.alpha)),c&&r===m-1)break;Cartesian3.pack(b,o,D),D+=3,defined(n)&&(a=n[r],i[G++]=Color.floatToByte(a.red),i[G++]=Color.floatToByte(a.green),i[G++]=Color.floatToByte(a.blue),i[G++]=Color.floatToByte(a.alpha))}}var k=new GeometryAttributes;k.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:o}),defined(n)&&(k.color=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:i,normalize:!0}));var S=2*((t=o.length/3)-1),j=IndexDatatype.createTypedArray(t,S),V=0;for(r=0;r<t-1;++r)j[V++]=r,j[V++]=r+1;return new Geometry({attributes:k,indices:j,primitiveType:PrimitiveType.LINES,boundingSphere:BoundingSphere.fromPoints(l)})};export default SimplePolylineGeometry;