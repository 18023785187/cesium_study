import arrayFill from"./arrayFill.js";import arrayRemoveDuplicates from"./arrayRemoveDuplicates.js";import BoundingSphere from"./BoundingSphere.js";import Cartesian3 from"./Cartesian3.js";import Cartographic from"./Cartographic.js";import Check from"./Check.js";import ComponentDatatype from"./ComponentDatatype.js";import CornerType from"./CornerType.js";import CorridorGeometryLibrary from"./CorridorGeometryLibrary.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import Ellipsoid from"./Ellipsoid.js";import Geometry from"./Geometry.js";import GeometryAttribute from"./GeometryAttribute.js";import GeometryAttributes from"./GeometryAttributes.js";import GeometryOffsetAttribute from"./GeometryOffsetAttribute.js";import IndexDatatype from"./IndexDatatype.js";import CesiumMath from"./Math.js";import PolygonPipeline from"./PolygonPipeline.js";import PrimitiveType from"./PrimitiveType.js";import Rectangle from"./Rectangle.js";import VertexFormat from"./VertexFormat.js";var cartesian1=new Cartesian3,cartesian2=new Cartesian3,cartesian3=new Cartesian3,cartesian4=new Cartesian3,cartesian5=new Cartesian3,cartesian6=new Cartesian3,scratch1=new Cartesian3,scratch2=new Cartesian3;function scaleToSurface(t,r){for(var a=0;a<t.length;a++)t[a]=r.scaleToGeodeticSurface(t[a],t[a]);return t}function addNormals(t,r,a,e,i,o){var n=t.normals,s=t.tangents,c=t.bitangents,d=Cartesian3.normalize(Cartesian3.cross(a,r,scratch1),scratch1);o.normal&&CorridorGeometryLibrary.addAttribute(n,r,e,i),o.tangent&&CorridorGeometryLibrary.addAttribute(s,d,e,i),o.bitangent&&CorridorGeometryLibrary.addAttribute(c,a,e,i)}function combine(t,r,a){var e,i,o,n=t.positions,s=t.corners,c=t.endPositions,d=t.lefts,l=t.normals,h=new GeometryAttributes,u=0,m=0,p=0;for(i=0;i<n.length;i+=2)u+=o=n[i].length-3,p+=2*o,m+=n[i+1].length-3;for(u+=3,m+=3,i=0;i<s.length;i++){e=s[i];var C=s[i].leftPositions;defined(C)?(u+=o=C.length,p+=o):(m+=o=s[i].rightPositions.length,p+=o)}var f,g=defined(c);g&&(u+=f=c[0].length-3,m+=f,p+=6*(f/=3));var y,b,v,A,_,w,G=u+m,x=new Float64Array(G),M={normals:r.normal?new Float32Array(G):void 0,tangents:r.tangent?new Float32Array(G):void 0,bitangents:r.bitangent?new Float32Array(G):void 0},O=0,T=G-1,E=cartesian1,V=cartesian2,F=f/2,P=IndexDatatype.createTypedArray(G/3,p),N=0;if(g){w=cartesian3,_=cartesian4;var L=c[0];for(E=Cartesian3.fromArray(l,0,E),V=Cartesian3.fromArray(d,0,V),i=0;i<F;i++)w=Cartesian3.fromArray(L,3*(F-1-i),w),_=Cartesian3.fromArray(L,3*(F+i),_),CorridorGeometryLibrary.addAttribute(x,_,O),CorridorGeometryLibrary.addAttribute(x,w,void 0,T),addNormals(M,E,V,O,T,r),A=1+(b=O/3),v=(y=(T-2)/3)-1,P[N++]=y,P[N++]=b,P[N++]=v,P[N++]=v,P[N++]=b,P[N++]=A,O+=3,T-=3}var D,I,S=0,k=0,R=n[S++],j=n[S++];for(x.set(R,O),x.set(j,T-j.length+1),V=Cartesian3.fromArray(d,k,V),o=j.length-3,i=0;i<o;i+=3)D=a.geodeticSurfaceNormal(Cartesian3.fromArray(R,i,scratch1),scratch1),I=a.geodeticSurfaceNormal(Cartesian3.fromArray(j,o-i,scratch2),scratch2),addNormals(M,E=Cartesian3.normalize(Cartesian3.add(D,I,E),E),V,O,T,r),A=1+(b=O/3),v=(y=(T-2)/3)-1,P[N++]=y,P[N++]=b,P[N++]=v,P[N++]=v,P[N++]=b,P[N++]=A,O+=3,T-=3;for(D=a.geodeticSurfaceNormal(Cartesian3.fromArray(R,o,scratch1),scratch1),I=a.geodeticSurfaceNormal(Cartesian3.fromArray(j,o,scratch2),scratch2),E=Cartesian3.normalize(Cartesian3.add(D,I,E),E),k+=3,i=0;i<s.length;i++){var H,z,B,U=(e=s[i]).leftPositions,W=e.rightPositions,Y=cartesian6,q=cartesian3,J=cartesian4;if(E=Cartesian3.fromArray(l,k,E),defined(U)){for(addNormals(M,E,V,void 0,T,r),T-=3,z=A,B=v,H=0;H<U.length/3;H++)Y=Cartesian3.fromArray(U,3*H,Y),P[N++]=z,P[N++]=B-H-1,P[N++]=B-H,CorridorGeometryLibrary.addAttribute(x,Y,void 0,T),q=Cartesian3.fromArray(x,3*(B-H-1),q),J=Cartesian3.fromArray(x,3*z,J),addNormals(M,E,V=Cartesian3.normalize(Cartesian3.subtract(q,J,V),V),void 0,T,r),T-=3;Y=Cartesian3.fromArray(x,3*z,Y),q=Cartesian3.subtract(Cartesian3.fromArray(x,3*B,q),Y,q),J=Cartesian3.subtract(Cartesian3.fromArray(x,3*(B-H),J),Y,J),addNormals(M,E,V=Cartesian3.normalize(Cartesian3.add(q,J,V),V),O,void 0,r),O+=3}else{for(addNormals(M,E,V,O,void 0,r),O+=3,z=v,B=A,H=0;H<W.length/3;H++)Y=Cartesian3.fromArray(W,3*H,Y),P[N++]=z,P[N++]=B+H,P[N++]=B+H+1,CorridorGeometryLibrary.addAttribute(x,Y,O),q=Cartesian3.fromArray(x,3*z,q),J=Cartesian3.fromArray(x,3*(B+H),J),addNormals(M,E,V=Cartesian3.normalize(Cartesian3.subtract(q,J,V),V),O,void 0,r),O+=3;Y=Cartesian3.fromArray(x,3*z,Y),q=Cartesian3.subtract(Cartesian3.fromArray(x,3*(B+H),q),Y,q),J=Cartesian3.subtract(Cartesian3.fromArray(x,3*B,J),Y,J),addNormals(M,E,V=Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(J,q,V),V),V),void 0,T,r),T-=3}for(R=n[S++],j=n[S++],R.splice(0,3),j.splice(j.length-3,3),x.set(R,O),x.set(j,T-j.length+1),o=j.length-3,k+=3,V=Cartesian3.fromArray(d,k,V),H=0;H<j.length;H+=3)D=a.geodeticSurfaceNormal(Cartesian3.fromArray(R,H,scratch1),scratch1),I=a.geodeticSurfaceNormal(Cartesian3.fromArray(j,o-H,scratch2),scratch2),addNormals(M,E=Cartesian3.normalize(Cartesian3.add(D,I,E),E),V,O,T,r),b=(A=O/3)-1,y=1+(v=(T-2)/3),P[N++]=y,P[N++]=b,P[N++]=v,P[N++]=v,P[N++]=b,P[N++]=A,O+=3,T-=3;O-=3,T+=3}if(addNormals(M,E=Cartesian3.fromArray(l,l.length-3,E),V,O,T,r),g){O+=3,T-=3,w=cartesian3,_=cartesian4;var K=c[1];for(i=0;i<F;i++)w=Cartesian3.fromArray(K,3*(f-i-1),w),_=Cartesian3.fromArray(K,3*i,_),CorridorGeometryLibrary.addAttribute(x,w,void 0,T),CorridorGeometryLibrary.addAttribute(x,_,O),addNormals(M,E,V,O,T,r),b=(A=O/3)-1,y=1+(v=(T-2)/3),P[N++]=y,P[N++]=b,P[N++]=v,P[N++]=v,P[N++]=b,P[N++]=A,O+=3,T-=3}if(h.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:x}),r.st){var Q,X,Z=new Float32Array(G/3*2),$=0;if(g){u/=3,m/=3;var tt,rt=Math.PI/(f+1);X=1/(u-f+1),Q=1/(m-f+1);var at=f/2;for(i=at+1;i<f+1;i++)tt=CesiumMath.PI_OVER_TWO+rt*i,Z[$++]=Q*(1+Math.cos(tt)),Z[$++]=.5*(1+Math.sin(tt));for(i=1;i<m-f+1;i++)Z[$++]=i*Q,Z[$++]=0;for(i=f;i>at;i--)tt=CesiumMath.PI_OVER_TWO-i*rt,Z[$++]=1-Q*(1+Math.cos(tt)),Z[$++]=.5*(1+Math.sin(tt));for(i=at;i>0;i--)tt=CesiumMath.PI_OVER_TWO-rt*i,Z[$++]=1-X*(1+Math.cos(tt)),Z[$++]=.5*(1+Math.sin(tt));for(i=u-f;i>0;i--)Z[$++]=i*X,Z[$++]=1;for(i=1;i<at+1;i++)tt=CesiumMath.PI_OVER_TWO+rt*i,Z[$++]=X*(1+Math.cos(tt)),Z[$++]=.5*(1+Math.sin(tt))}else{for(X=1/((u/=3)-1),Q=1/((m/=3)-1),i=0;i<m;i++)Z[$++]=i*Q,Z[$++]=0;for(i=u;i>0;i--)Z[$++]=(i-1)*X,Z[$++]=1}h.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:Z})}return r.normal&&(h.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:M.normals})),r.tangent&&(h.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:M.tangents})),r.bitangent&&(h.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:M.bitangents})),{attributes:h,indices:P}}function extrudedAttributes(t,r){if(!(r.normal||r.tangent||r.bitangent||r.st))return t;var a,e,i=t.position.values;(r.normal||r.bitangent)&&(a=t.normal.values,e=t.bitangent.values);var o,n=t.position.values.length/18,s=3*n,c=2*n,d=2*s;if(r.normal||r.bitangent||r.tangent){var l=r.normal?new Float32Array(6*s):void 0,h=r.tangent?new Float32Array(6*s):void 0,u=r.bitangent?new Float32Array(6*s):void 0,m=cartesian1,p=cartesian2,C=cartesian3,f=cartesian4,g=cartesian5,y=cartesian6,b=d;for(o=0;o<s;o+=3){var v=b+d;m=Cartesian3.fromArray(i,o,m),p=Cartesian3.fromArray(i,o+s,p),C=Cartesian3.fromArray(i,(o+3)%s,C),p=Cartesian3.subtract(p,m,p),C=Cartesian3.subtract(C,m,C),f=Cartesian3.normalize(Cartesian3.cross(p,C,f),f),r.normal&&(CorridorGeometryLibrary.addAttribute(l,f,v),CorridorGeometryLibrary.addAttribute(l,f,v+3),CorridorGeometryLibrary.addAttribute(l,f,b),CorridorGeometryLibrary.addAttribute(l,f,b+3)),(r.tangent||r.bitangent)&&(y=Cartesian3.fromArray(a,o,y),r.bitangent&&(CorridorGeometryLibrary.addAttribute(u,y,v),CorridorGeometryLibrary.addAttribute(u,y,v+3),CorridorGeometryLibrary.addAttribute(u,y,b),CorridorGeometryLibrary.addAttribute(u,y,b+3)),r.tangent&&(g=Cartesian3.normalize(Cartesian3.cross(y,f,g),g),CorridorGeometryLibrary.addAttribute(h,g,v),CorridorGeometryLibrary.addAttribute(h,g,v+3),CorridorGeometryLibrary.addAttribute(h,g,b),CorridorGeometryLibrary.addAttribute(h,g,b+3))),b+=6}if(r.normal){for(l.set(a),o=0;o<s;o+=3)l[o+s]=-a[o],l[o+s+1]=-a[o+1],l[o+s+2]=-a[o+2];t.normal.values=l}else t.normal=void 0;if(r.bitangent?(u.set(e),u.set(e,s),t.bitangent.values=u):t.bitangent=void 0,r.tangent){var A=t.tangent.values;h.set(A),h.set(A,s),t.tangent.values=h}}if(r.st){var _=t.st.values,w=new Float32Array(6*c);w.set(_),w.set(_,c);for(var G=2*c,x=0;x<2;x++){for(w[G++]=_[0],w[G++]=_[1],o=2;o<c;o+=2){var M=_[o],O=_[o+1];w[G++]=M,w[G++]=O,w[G++]=M,w[G++]=O}w[G++]=_[0],w[G++]=_[1]}t.st.values=w}return t}function addWallPositions(t,r,a){a[r++]=t[0],a[r++]=t[1],a[r++]=t[2];for(var e=3;e<t.length;e+=3){var i=t[e],o=t[e+1],n=t[e+2];a[r++]=i,a[r++]=o,a[r++]=n,a[r++]=i,a[r++]=o,a[r++]=n}return a[r++]=t[0],a[r++]=t[1],a[r++]=t[2],a}function computePositionsExtruded(t,r){var a=new VertexFormat({position:r.position,normal:r.normal||r.bitangent||t.shadowVolume,tangent:r.tangent,bitangent:r.normal||r.bitangent,st:r.st}),e=t.ellipsoid,i=combine(CorridorGeometryLibrary.computePositions(t),a,e),o=t.height,n=t.extrudedHeight,s=i.attributes,c=i.indices,d=s.position.values,l=d.length,h=new Float64Array(6*l),u=new Float64Array(l);u.set(d);var m,p=new Float64Array(4*l);p=addWallPositions(d=PolygonPipeline.scaleToGeodeticHeight(d,o,e),0,p),p=addWallPositions(u=PolygonPipeline.scaleToGeodeticHeight(u,n,e),2*l,p),h.set(d),h.set(u,l),h.set(p,2*l),s.position.values=h,s=extrudedAttributes(s,r);var C=l/3;if(t.shadowVolume){var f=s.normal.values;l=f.length;var g=new Float32Array(6*l);for(m=0;m<l;m++)f[m]=-f[m];g.set(f,l),g=addWallPositions(f,4*l,g),s.extrudeDirection=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:g}),r.normal||(s.normal=void 0)}if(defined(t.offsetAttribute)){var y=new Uint8Array(6*C);if(t.offsetAttribute===GeometryOffsetAttribute.TOP)y=arrayFill(y,1,0,C),y=arrayFill(y,1,2*C,4*C);else{var b=t.offsetAttribute===GeometryOffsetAttribute.NONE?0:1;y=arrayFill(y,b)}s.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:y})}var v=c.length,A=C+C,_=IndexDatatype.createTypedArray(h.length/3,2*v+3*A);_.set(c);var w,G,x,M,O=v;for(m=0;m<v;m+=3){var T=c[m],E=c[m+1],V=c[m+2];_[O++]=V+C,_[O++]=E+C,_[O++]=T+C}for(m=0;m<A;m+=2)x=(w=m+A)+1,M=(G=w+A)+1,_[O++]=w,_[O++]=G,_[O++]=x,_[O++]=x,_[O++]=G,_[O++]=M;return{attributes:s,indices:_}}var scratchCartesian1=new Cartesian3,scratchCartesian2=new Cartesian3,scratchCartographic=new Cartographic;function computeOffsetPoints(t,r,a,e,i,o){var n=Cartesian3.subtract(r,t,scratchCartesian1);Cartesian3.normalize(n,n);var s=a.geodeticSurfaceNormal(t,scratchCartesian2),c=Cartesian3.cross(n,s,scratchCartesian1);Cartesian3.multiplyByScalar(c,e,c);var d=i.latitude,l=i.longitude,h=o.latitude,u=o.longitude;Cartesian3.add(t,c,scratchCartesian2),a.cartesianToCartographic(scratchCartesian2,scratchCartographic);var m=scratchCartographic.latitude,p=scratchCartographic.longitude;d=Math.min(d,m),l=Math.min(l,p),h=Math.max(h,m),u=Math.max(u,p),Cartesian3.subtract(t,c,scratchCartesian2),a.cartesianToCartographic(scratchCartesian2,scratchCartographic),m=scratchCartographic.latitude,p=scratchCartographic.longitude,d=Math.min(d,m),l=Math.min(l,p),h=Math.max(h,m),u=Math.max(u,p),i.latitude=d,i.longitude=l,o.latitude=h,o.longitude=u}var scratchCartesianOffset=new Cartesian3,scratchCartesianEnds=new Cartesian3,scratchCartographicMin=new Cartographic,scratchCartographicMax=new Cartographic;function computeRectangle(t,r,a,e,i){t=scaleToSurface(t,r);var o=arrayRemoveDuplicates(t,Cartesian3.equalsEpsilon),n=o.length;if(n<2||a<=0)return new Rectangle;var s,c,d=.5*a;if(scratchCartographicMin.latitude=Number.POSITIVE_INFINITY,scratchCartographicMin.longitude=Number.POSITIVE_INFINITY,scratchCartographicMax.latitude=Number.NEGATIVE_INFINITY,scratchCartographicMax.longitude=Number.NEGATIVE_INFINITY,e===CornerType.ROUNDED){var l=o[0];Cartesian3.subtract(l,o[1],scratchCartesianOffset),Cartesian3.normalize(scratchCartesianOffset,scratchCartesianOffset),Cartesian3.multiplyByScalar(scratchCartesianOffset,d,scratchCartesianOffset),Cartesian3.add(l,scratchCartesianOffset,scratchCartesianEnds),r.cartesianToCartographic(scratchCartesianEnds,scratchCartographic),s=scratchCartographic.latitude,c=scratchCartographic.longitude,scratchCartographicMin.latitude=Math.min(scratchCartographicMin.latitude,s),scratchCartographicMin.longitude=Math.min(scratchCartographicMin.longitude,c),scratchCartographicMax.latitude=Math.max(scratchCartographicMax.latitude,s),scratchCartographicMax.longitude=Math.max(scratchCartographicMax.longitude,c)}for(var h=0;h<n-1;++h)computeOffsetPoints(o[h],o[h+1],r,d,scratchCartographicMin,scratchCartographicMax);var u=o[n-1];Cartesian3.subtract(u,o[n-2],scratchCartesianOffset),Cartesian3.normalize(scratchCartesianOffset,scratchCartesianOffset),Cartesian3.multiplyByScalar(scratchCartesianOffset,d,scratchCartesianOffset),Cartesian3.add(u,scratchCartesianOffset,scratchCartesianEnds),computeOffsetPoints(u,scratchCartesianEnds,r,d,scratchCartographicMin,scratchCartographicMax),e===CornerType.ROUNDED&&(r.cartesianToCartographic(scratchCartesianEnds,scratchCartographic),s=scratchCartographic.latitude,c=scratchCartographic.longitude,scratchCartographicMin.latitude=Math.min(scratchCartographicMin.latitude,s),scratchCartographicMin.longitude=Math.min(scratchCartographicMin.longitude,c),scratchCartographicMax.latitude=Math.max(scratchCartographicMax.latitude,s),scratchCartographicMax.longitude=Math.max(scratchCartographicMax.longitude,c));var m=defined(i)?i:new Rectangle;return m.north=scratchCartographicMax.latitude,m.south=scratchCartographicMin.latitude,m.east=scratchCartographicMax.longitude,m.west=scratchCartographicMin.longitude,m}function CorridorGeometry(t){var r=(t=defaultValue(t,defaultValue.EMPTY_OBJECT)).positions,a=t.width;Check.defined("options.positions",r),Check.defined("options.width",a);var e=defaultValue(t.height,0),i=defaultValue(t.extrudedHeight,e);this._positions=r,this._ellipsoid=Ellipsoid.clone(defaultValue(t.ellipsoid,Ellipsoid.WGS84)),this._vertexFormat=VertexFormat.clone(defaultValue(t.vertexFormat,VertexFormat.DEFAULT)),this._width=a,this._height=Math.max(e,i),this._extrudedHeight=Math.min(e,i),this._cornerType=defaultValue(t.cornerType,CornerType.ROUNDED),this._granularity=defaultValue(t.granularity,CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+r.length*Cartesian3.packedLength+Ellipsoid.packedLength+VertexFormat.packedLength+7}CorridorGeometry.pack=function(t,r,a){Check.defined("value",t),Check.defined("array",r),a=defaultValue(a,0);var e=t._positions,i=e.length;r[a++]=i;for(var o=0;o<i;++o,a+=Cartesian3.packedLength)Cartesian3.pack(e[o],r,a);return Ellipsoid.pack(t._ellipsoid,r,a),a+=Ellipsoid.packedLength,VertexFormat.pack(t._vertexFormat,r,a),a+=VertexFormat.packedLength,r[a++]=t._width,r[a++]=t._height,r[a++]=t._extrudedHeight,r[a++]=t._cornerType,r[a++]=t._granularity,r[a++]=t._shadowVolume?1:0,r[a]=defaultValue(t._offsetAttribute,-1),r};var scratchEllipsoid=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchVertexFormat=new VertexFormat,scratchOptions={positions:void 0,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};CorridorGeometry.unpack=function(t,r,a){Check.defined("array",t),r=defaultValue(r,0);for(var e=t[r++],i=new Array(e),o=0;o<e;++o,r+=Cartesian3.packedLength)i[o]=Cartesian3.unpack(t,r);var n=Ellipsoid.unpack(t,r,scratchEllipsoid);r+=Ellipsoid.packedLength;var s=VertexFormat.unpack(t,r,scratchVertexFormat);r+=VertexFormat.packedLength;var c=t[r++],d=t[r++],l=t[r++],h=t[r++],u=t[r++],m=1===t[r++],p=t[r];return defined(a)?(a._positions=i,a._ellipsoid=Ellipsoid.clone(n,a._ellipsoid),a._vertexFormat=VertexFormat.clone(s,a._vertexFormat),a._width=c,a._height=d,a._extrudedHeight=l,a._cornerType=h,a._granularity=u,a._shadowVolume=m,a._offsetAttribute=-1===p?void 0:p,a):(scratchOptions.positions=i,scratchOptions.width=c,scratchOptions.height=d,scratchOptions.extrudedHeight=l,scratchOptions.cornerType=h,scratchOptions.granularity=u,scratchOptions.shadowVolume=m,scratchOptions.offsetAttribute=-1===p?void 0:p,new CorridorGeometry(scratchOptions))},CorridorGeometry.computeRectangle=function(t,r){var a=(t=defaultValue(t,defaultValue.EMPTY_OBJECT)).positions,e=t.width;return Check.defined("options.positions",a),Check.defined("options.width",e),computeRectangle(a,defaultValue(t.ellipsoid,Ellipsoid.WGS84),e,defaultValue(t.cornerType,CornerType.ROUNDED),r)},CorridorGeometry.createGeometry=function(t){var r=t._positions,a=t._width,e=t._ellipsoid;r=scaleToSurface(r,e);var i=arrayRemoveDuplicates(r,Cartesian3.equalsEpsilon);if(!(i.length<2||a<=0)){var o,n=t._height,s=t._extrudedHeight,c=!CesiumMath.equalsEpsilon(n,s,0,CesiumMath.EPSILON2),d=t._vertexFormat,l={ellipsoid:e,positions:i,width:a,cornerType:t._cornerType,granularity:t._granularity,saveAttributes:!0};if(c)l.height=n,l.extrudedHeight=s,l.shadowVolume=t._shadowVolume,l.offsetAttribute=t._offsetAttribute,o=computePositionsExtruded(l,d);else if((o=combine(CorridorGeometryLibrary.computePositions(l),d,e)).attributes.position.values=PolygonPipeline.scaleToGeodeticHeight(o.attributes.position.values,n,e),defined(t._offsetAttribute)){var h=t._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,u=o.attributes.position.values.length,m=new Uint8Array(u/3);arrayFill(m,h),o.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:m})}var p=o.attributes,C=BoundingSphere.fromVertices(p.position.values,void 0,3);return d.position||(o.attributes.position.values=void 0),new Geometry({attributes:p,indices:o.indices,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:C,offsetAttribute:t._offsetAttribute})}},CorridorGeometry.createShadowVolume=function(t,r,a){var e=t._granularity,i=t._ellipsoid,o=r(e,i),n=a(e,i);return new CorridorGeometry({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:e,extrudedHeight:o,height:n,vertexFormat:VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(CorridorGeometry.prototype,{rectangle:{get:function(){return defined(this._rectangle)||(this._rectangle=computeRectangle(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});export default CorridorGeometry;