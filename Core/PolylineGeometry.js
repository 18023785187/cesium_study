import ArcType from"./ArcType.js";import arrayRemoveDuplicates from"./arrayRemoveDuplicates.js";import BoundingSphere from"./BoundingSphere.js";import Cartesian3 from"./Cartesian3.js";import Color from"./Color.js";import ComponentDatatype from"./ComponentDatatype.js";import defaultValue from"./defaultValue.js";import defined from"./defined.js";import DeveloperError from"./DeveloperError.js";import Ellipsoid from"./Ellipsoid.js";import Geometry from"./Geometry.js";import GeometryAttribute from"./GeometryAttribute.js";import GeometryAttributes from"./GeometryAttributes.js";import GeometryType from"./GeometryType.js";import IndexDatatype from"./IndexDatatype.js";import CesiumMath from"./Math.js";import PolylinePipeline from"./PolylinePipeline.js";import PrimitiveType from"./PrimitiveType.js";import VertexFormat from"./VertexFormat.js";var scratchInterpolateColorsArray=[];function interpolateColors(e,r,t,o,a){var i,n=scratchInterpolateColorsArray;n.length=a;var l=t.red,s=t.green,p=t.blue,c=t.alpha,m=o.red,d=o.green,y=o.blue,h=o.alpha;if(Color.equals(t,o)){for(i=0;i<a;i++)n[i]=Color.clone(t);return n}var u=(m-l)/a,f=(d-s)/a,v=(y-p)/a,C=(h-c)/a;for(i=0;i<a;i++)n[i]=new Color(l+i*u,s+i*f,p+i*v,c+i*C);return n}function PolylineGeometry(e){var r=(e=defaultValue(e,defaultValue.EMPTY_OBJECT)).positions,t=e.colors,o=defaultValue(e.width,1),a=defaultValue(e.colorsPerVertex,!1);if(!defined(r)||r.length<2)throw new DeveloperError("At least two positions are required.");if("number"!=typeof o)throw new DeveloperError("width must be a number");if(defined(t)&&(a&&t.length<r.length||!a&&t.length<r.length-1))throw new DeveloperError("colors has an invalid length.");this._positions=r,this._colors=t,this._width=o,this._colorsPerVertex=a,this._vertexFormat=VertexFormat.clone(defaultValue(e.vertexFormat,VertexFormat.DEFAULT)),this._arcType=defaultValue(e.arcType,ArcType.GEODESIC),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";var i=1+r.length*Cartesian3.packedLength;i+=defined(t)?1+t.length*Color.packedLength:1,this.packedLength=i+Ellipsoid.packedLength+VertexFormat.packedLength+4}PolylineGeometry.pack=function(e,r,t){if(!defined(e))throw new DeveloperError("value is required");if(!defined(r))throw new DeveloperError("array is required");var o;t=defaultValue(t,0);var a=e._positions,i=a.length;for(r[t++]=i,o=0;o<i;++o,t+=Cartesian3.packedLength)Cartesian3.pack(a[o],r,t);var n=e._colors;for(i=defined(n)?n.length:0,r[t++]=i,o=0;o<i;++o,t+=Color.packedLength)Color.pack(n[o],r,t);return Ellipsoid.pack(e._ellipsoid,r,t),t+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,r,t),t+=VertexFormat.packedLength,r[t++]=e._width,r[t++]=e._colorsPerVertex?1:0,r[t++]=e._arcType,r[t]=e._granularity,r};var scratchEllipsoid=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchVertexFormat=new VertexFormat,scratchOptions={positions:void 0,colors:void 0,ellipsoid:scratchEllipsoid,vertexFormat:scratchVertexFormat,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};PolylineGeometry.unpack=function(e,r,t){if(!defined(e))throw new DeveloperError("array is required");var o;r=defaultValue(r,0);var a=e[r++],i=new Array(a);for(o=0;o<a;++o,r+=Cartesian3.packedLength)i[o]=Cartesian3.unpack(e,r);var n=(a=e[r++])>0?new Array(a):void 0;for(o=0;o<a;++o,r+=Color.packedLength)n[o]=Color.unpack(e,r);var l=Ellipsoid.unpack(e,r,scratchEllipsoid);r+=Ellipsoid.packedLength;var s=VertexFormat.unpack(e,r,scratchVertexFormat);r+=VertexFormat.packedLength;var p=e[r++],c=1===e[r++],m=e[r++],d=e[r];return defined(t)?(t._positions=i,t._colors=n,t._ellipsoid=Ellipsoid.clone(l,t._ellipsoid),t._vertexFormat=VertexFormat.clone(s,t._vertexFormat),t._width=p,t._colorsPerVertex=c,t._arcType=m,t._granularity=d,t):(scratchOptions.positions=i,scratchOptions.colors=n,scratchOptions.width=p,scratchOptions.colorsPerVertex=c,scratchOptions.arcType=m,scratchOptions.granularity=d,new PolylineGeometry(scratchOptions))};var scratchCartesian3=new Cartesian3,scratchPosition=new Cartesian3,scratchPrevPosition=new Cartesian3,scratchNextPosition=new Cartesian3;PolylineGeometry.createGeometry=function(e){var r,t,o,a=e._width,i=e._vertexFormat,n=e._colors,l=e._colorsPerVertex,s=e._arcType,p=e._granularity,c=e._ellipsoid,m=[],d=arrayRemoveDuplicates(e._positions,Cartesian3.equalsEpsilon,!1,m);if(defined(n)&&m.length>0){var y=0,h=m[0];n=n.filter((function(e,r){return!(l?r===h||0===r&&1===h:r+1===h)||(y++,h=m[y],!1)}))}var u=d.length;if(!(u<2||a<=0)){if(s===ArcType.GEODESIC||s===ArcType.RHUMB){var f,v;s===ArcType.GEODESIC?(f=CesiumMath.chordLength(p,c.maximumRadius),v=PolylinePipeline.numberOfPoints):(f=p,v=PolylinePipeline.numberOfPointsRhumbLine);var C=PolylinePipeline.extractHeights(d,c);if(defined(n)){var P=1;for(r=0;r<u-1;++r)P+=v(d[r],d[r+1],f);var g=new Array(P),E=0;for(r=0;r<u-1;++r){var A=d[r],w=d[r+1],x=n[r],D=v(A,w,f);if(l&&r<P){var _=interpolateColors(A,w,x,n[r+1],D),T=_.length;for(t=0;t<T;++t)g[E++]=_[t]}else for(t=0;t<D;++t)g[E++]=Color.clone(x)}g[E]=Color.clone(n[n.length-1]),n=g,scratchInterpolateColorsArray.length=0}d=s===ArcType.GEODESIC?PolylinePipeline.generateCartesianArc({positions:d,minDistance:f,ellipsoid:c,height:C}):PolylinePipeline.generateCartesianRhumbArc({positions:d,granularity:f,ellipsoid:c,height:C})}var G,V=4*(u=d.length)-4,b=new Float64Array(3*V),F=new Float64Array(3*V),k=new Float64Array(3*V),L=new Float32Array(2*V),O=i.st?new Float32Array(2*V):void 0,j=defined(n)?new Uint8Array(4*V):void 0,I=0,S=0,B=0,R=0;for(t=0;t<u;++t){var N,U;0===t?(G=scratchCartesian3,Cartesian3.subtract(d[0],d[1],G),Cartesian3.add(d[0],G,G)):G=d[t-1],Cartesian3.clone(G,scratchPrevPosition),Cartesian3.clone(d[t],scratchPosition),t===u-1?(G=scratchCartesian3,Cartesian3.subtract(d[u-1],d[u-2],G),Cartesian3.add(d[u-1],G,G)):G=d[t+1],Cartesian3.clone(G,scratchNextPosition),defined(j)&&(N=0===t||l?n[t]:n[t-1],t!==u-1&&(U=n[t]));var M=t===u-1?2:4;for(o=0===t?2:0;o<M;++o){Cartesian3.pack(scratchPosition,b,I),Cartesian3.pack(scratchPrevPosition,F,I),Cartesian3.pack(scratchNextPosition,k,I),I+=3;var q=o-2<0?-1:1;if(L[S++]=o%2*2-1,L[S++]=q*a,i.st&&(O[B++]=t/(u-1),O[B++]=Math.max(L[S-2],0)),defined(j)){var H=o<2?N:U;j[R++]=Color.floatToByte(H.red),j[R++]=Color.floatToByte(H.green),j[R++]=Color.floatToByte(H.blue),j[R++]=Color.floatToByte(H.alpha)}}}var Y=new GeometryAttributes;Y.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:b}),Y.prevPosition=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F}),Y.nextPosition=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:k}),Y.expandAndWidth=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:L}),i.st&&(Y.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:O})),defined(j)&&(Y.color=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:j,normalize:!0}));var W=IndexDatatype.createTypedArray(V,6*u-6),z=0,J=0,K=u-1;for(t=0;t<K;++t)W[J++]=z,W[J++]=z+2,W[J++]=z+1,W[J++]=z+1,W[J++]=z+2,W[J++]=z+3,z+=4;return new Geometry({attributes:Y,indices:W,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:BoundingSphere.fromPoints(d),geometryType:GeometryType.POLYLINES})}};export default PolylineGeometry;